 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/routes/admin.py b/backend/app/routes/admin.py
index 2c2fc018ad0f8b8f67113dfcd027167e9beef865..d4b17093e069e062fca6737321364644ae5295ff 100644
--- a/backend/app/routes/admin.py
+++ b/backend/app/routes/admin.py
@@ -51,50 +51,58 @@ def _profession_label_expression(db: Session):
             .scalar_subquery()
         )
     return literal(None)
 
 
 def _iter_months(start: date, end: date) -> List[str]:
     current = date(start.year, start.month, 1)
     end_month = date(end.year, end.month, 1)
     months: List[str] = []
     while current <= end_month:
         months.append(current.strftime("%Y-%m"))
         if current.month == 12:
             current = date(current.year + 1, 1, 1)
         else:
             current = date(current.year, current.month + 1, 1)
     return months
 
 
 def _add_months(start: date, months: int) -> date:
     month_index = start.month - 1 + months
     year = start.year + month_index // 12
     month = month_index % 12 + 1
     return date(year, month, 1)
 
 
+def _month_key_expr(db: Session, dt_col):
+    dialect = getattr(getattr(db, "bind", None), "dialect", None)
+    name = getattr(dialect, "name", "") if dialect else ""
+    if name == "sqlite":
+        return func.strftime("%Y-%m", dt_col)
+    return func.to_char(dt_col, "YYYY-MM")
+
+
 @router.get("/service-charge", response_model=schemas.ServiceChargeOut)
 def get_service_charge(
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     pct = crud.get_platform_service_charge_percentage(db)
     return {"service_charge_percentage": float(pct)}
 
 
 @router.put("/service-charge", response_model=schemas.ServiceChargeOut)
 def update_service_charge(
     payload: schemas.ServiceChargeUpdate,
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     pct = crud.update_platform_service_charge(db, payload.service_charge_percentage)
     return {"service_charge_percentage": float(pct)}
 
 
 @router.get("/providers/locations", response_model=List[schemas.AdminProviderLocationOut])
 def list_provider_locations(
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     return crud.list_admin_provider_locations(db)
@@ -543,70 +551,71 @@ def get_provider_retention(
     end: Optional[date] = Query(None),
     profession: Optional[str] = Query(None),
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     if start and end and start > end:
         raise HTTPException(status_code=400, detail="Start date must be on or before end date")
 
     if start and end:
         start_date = date(start.year, start.month, 1)
         end_date = end
     else:
         today = date.today()
         end_date = today
         start_date = _add_months(date(today.year, today.month, 1), -(months_back - 1))
 
     months = _iter_months(start_date, end_date)
     start_ts = datetime.combine(start_date, time.min)
     end_ts_exclusive = datetime.combine(end_date + timedelta(days=1), time.min)
 
     _normalized_profession, provider_ids_subquery = _normalize_profession_filter(
         db,
         profession,
     )
     profession_label_expr = _profession_label_expression(db)
+    month_expr = _month_key_expr(db, models.Booking.start_time)
 
     retention_query = (
         db.query(
             models.Provider.id.label("provider_id"),
             models.User.username.label("provider_name"),
             profession_label_expr.label("profession"),
-            func.strftime("%Y-%m", models.Booking.start_time).label("month"),
+            month_expr.label("month"),
             func.count(models.Booking.id).label("bookings"),
         )
         .join(models.Service, models.Booking.service_id == models.Service.id)
         .join(models.Provider, models.Service.provider_id == models.Provider.id)
         .join(models.User, models.Provider.user_id == models.User.id)
         .filter(models.Booking.start_time >= start_ts)
         .filter(models.Booking.start_time < end_ts_exclusive)
         .filter(models.Booking.status != "cancelled")
         .group_by(
             models.Provider.id,
             models.User.username,
             profession_label_expr,
-            func.strftime("%Y-%m", models.Booking.start_time),
+            month_expr,
         )
     )
 
     if provider_ids_subquery is not None:
         retention_query = retention_query.filter(models.Provider.id.in_(provider_ids_subquery))
 
     retention_rows = retention_query.all()
 
     providers_map = defaultdict(lambda: {"active_months": set()})
     for row in retention_rows:
         providers_map[row.provider_id]["provider_id"] = row.provider_id
         providers_map[row.provider_id]["provider_name"] = row.provider_name
         providers_map[row.provider_id]["profession"] = row.profession
         providers_map[row.provider_id]["active_months"].add(row.month)
 
     providers = []
     for provider_id, payload in providers_map.items():
         active_months = sorted(payload["active_months"])
         last_active = active_months[-1] if active_months else None
         providers.append(
             {
                 "provider_id": provider_id,
                 "provider_name": payload.get("provider_name"),
                 "profession": payload.get("profession"),
                 "active_months": active_months,
 
EOF
)