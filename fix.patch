 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 6f51cd933cf4cab3e2d01e1e68cc8d85701852f3..09495d8995a408993bb594df41f8ead765a588b7 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -61,50 +61,56 @@ const API =
 
 const withTimeout = (promise, ms, label) => {
   let timeoutId;
   const timeout = new Promise((_, reject) => {
     timeoutId = setTimeout(() => {
       const error = new Error(`${label || "Operation"} timed out after ${ms}ms`);
       error.code = "ETIMEDOUT";
       reject(error);
     }, ms);
   });
 
   return Promise.race([promise, timeout]).finally(() => {
     clearTimeout(timeoutId);
   });
 };
 
 const AUTH_BOOTSTRAP_WATCHDOG_MS = 15000;
 const AUTH_TOKEN_TIMEOUT_MS = 2000;
 const AUTH_ME_TIMEOUT_MS = 12000;
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
+const isValidUsername = (value) => {
+  const trimmed = String(value || "").trim();
+  if (!trimmed) return false;
+  return /^[a-zA-Z0-9._-]+$/.test(trimmed);
+};
+
 const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
 const LEGACY_ACCESS_TOKEN_KEY = "accessToken";
 
 const getAuthToken = async (tokenState) => {
   if (tokenState?.token) return tokenState.token;
 
   try {
     const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await withTimeout(
       AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY),
       1500,
       "loadLegacyToken"
@@ -116,85 +122,94 @@ const getAuthToken = async (tokenState) => {
   }
 };
 
 const FAVORITES_STORAGE_KEY = (userKey) =>
   userKey ? `favoriteProviders:${userKey}` : "favoriteProviders";
 
 const getProviderId = (provider) =>
   provider?.provider_id ?? provider?.id ?? provider?._id ?? null;
 
 const RESERVED_USERNAME_PATHS = new Set([
   "u",
   "privacy",
   "terms",
   "download",
   "login",
   "signup",
   "forgot",
   "reset",
 ]);
 
 function extractUsernameFromUrl(url) {
   if (!url) return null;
   const trimmed = String(url).trim();
   if (!trimmed) return null;
 
+  // Strip query string or hash before parsing.
   const withoutQuery = trimmed.split(/[?#]/)[0];
   let pathname = withoutQuery;
 
-  try {
-    const parsed = new URL(withoutQuery);
-    pathname = parsed.pathname || "";
-  } catch (error) {
-    const schemeMatch = withoutQuery.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\/(.*)$/);
-    if (schemeMatch?.[1]) {
-      pathname = `/${schemeMatch[1]}`;
+  if (/^https?:\/\//i.test(withoutQuery)) {
+    // Strip protocol + host, keep only path.
+    const withoutProtocol = withoutQuery.replace(/^https?:\/\//i, "");
+    const slashIndex = withoutProtocol.indexOf("/");
+    pathname = slashIndex === -1 ? "/" : withoutProtocol.slice(slashIndex);
+  } else {
+    const schemeMatch = withoutQuery.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//);
+    if (schemeMatch) {
+      // Strip custom scheme and treat remainder as path.
+      pathname = `/${withoutQuery.slice(schemeMatch[0].length)}`;
     }
   }
 
+  if (!pathname.startsWith("/")) {
+    pathname = `/${pathname}`;
+  }
+
   const segments = pathname.split("/").filter(Boolean);
   if (segments.length === 0) return null;
 
   let username = null;
 
   if (segments[0] === "u" && segments[1]) {
     username = segments[1];
   } else if (segments.length === 1 && !RESERVED_USERNAME_PATHS.has(segments[0])) {
     username = segments[0];
   }
 
   if (!username) return null;
 
   let decoded = username;
   try {
     decoded = decodeURIComponent(username);
   } catch (error) {
     decoded = username;
   }
 
   const cleaned = decoded.trim().replace(/^@/, "");
-  return cleaned || null;
+  if (!cleaned || !isValidUsername(cleaned)) return null;
+  return cleaned;
 }
 
 function buildProviderPublicLink(username) {
   const trimmed = String(username || "").trim();
   if (!trimmed) return null;
   return `https://bookitgy.com/u/${encodeURIComponent(trimmed)}`;
 }
 
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
 
   const persistIds = useCallback(async (ids) => {
     try {
       await AsyncStorage.setItem(storageKey, JSON.stringify(ids));
     } catch (err) {
       console.log("Error saving favorites", err?.message || err);
     }
   }, [storageKey]);
 
   const loadFavoritesFromStorage = useCallback(async () => {
     try {
       setFavoritesLoading(true);
@@ -6022,59 +6037,63 @@ function App() {
     if (typeof text === "object") {
       if (Array.isArray(text.detail)) {
         return formatFlashText(text.detail);
       }
       if (typeof text.detail === "string") return text.detail;
       if (typeof text.message === "string") return text.message;
       if (typeof text.msg === "string") return text.msg;
       return JSON.stringify(text);
     }
 
     return String(text);
   };
 
   const showFlash = (type, text) => {
     setFlash({ type, text: formatFlashText(text) });
     setTimeout(() => {
       setFlash(null);
     }, 4500);
   };
 
   useEffect(() => {
     let isActive = true;
 
     Linking.getInitialURL().then((url) => {
       if (!isActive) return;
+      console.log("[deeplink] received initial url", url);
       const username = extractUsernameFromUrl(url);
+      console.log("[deeplink] extracted username", username);
       console.log("[deeplink] initial url", url, "username", username);
       if (username) {
         setPendingDeepLinkUsername(username);
       }
     });
 
     const sub = Linking.addEventListener("url", ({ url }) => {
+      console.log("[deeplink] received url event", url);
       const username = extractUsernameFromUrl(url);
+      console.log("[deeplink] extracted username", username);
       console.log("[deeplink] url event", url, "username", username);
       if (username) {
         setPendingDeepLinkUsername(username);
       }
     });
 
     return () => {
       isActive = false;
       sub.remove();
     };
   }, []);
 
   useEffect(() => {
     if (!pendingDeepLinkUsername || !token) return;
 
     if (token.isProvider) {
       console.log(
         "[deeplink] provider user ignoring username",
         pendingDeepLinkUsername
       );
       if (showFlash) {
         showFlash("error", "Open as a client to view provider links.");
       }
       setPendingDeepLinkUsername(null);
       return;
 
EOF
)