 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index ddb68a6a2d96e747d09721c256f1f1c65547dbf5..187479ba0855b6956430fec7093d99894996217a 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -3064,76 +3064,90 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
 
       const res = await axios.get(`${API}/providers`);
 
       // Always normalize the result to an array
       const list = Array.isArray(res.data)
         ? res.data
         : res.data?.providers || [];
 
       setProviders(list);
       setFilteredProviders(list);
       syncFavoritesFromList(list);
       return list;
     } catch (err) {
       console.log(
         "Error loading providers",
         err?.response?.data || err?.message
       );
       setProvidersError("Could not load providers.");
       if (showFlash) showFlash("error", "Could not load providers.");
       return [];
     } finally {
       setProvidersLoading(false);
     }
   }, [showFlash, syncFavoritesFromList]);
 
+  const clearSelectedProvider = useCallback(() => {
+    setSelectedProvider(null);
+    setServices([]);
+    setServicesError("");
+    setSelectedService(null);
+    setAvailability([]);
+    setAvailabilityError("");
+    setCatalogImages([]);
+    setCatalogError("");
+    setSelectedDate(null);
+    setSelectedSlot(null);
+  }, []);
+
   // Load providers on mount
   useEffect(() => {
     loadProviders();
   }, [loadProviders]);
 
   useEffect(() => {
     const providerFromNav = route?.params?.provider;
     if (!providerFromNav) return;
 
     const incomingId = getProviderId(providerFromNav);
     const currentId = getProviderId(selectedProvider);
     if (incomingId && incomingId === currentId) return;
 
     setSearchQuery(providerFromNav.name || "");
     setHasSearched(true);
     setFilteredProviders([providerFromNav]);
     handleSelectProvider(providerFromNav);
   }, [route?.params?.provider, selectedProvider, handleSelectProvider]);
 
   // Add a useEffect that recomputes filteredProviders
   // whenever providers/search/radius/location changes:
   useEffect(() => {
     // ðŸ‘‡ do nothing until the user actually searches or if the query is empty
     const normalizedQuery = normalizeSearchValue(searchQuery);
     if (!hasSearched || !normalizedQuery) {
       setFilteredProviders([]);
+      clearSelectedProvider();
       return;
     }
 
     const providerList = Array.isArray(providers) ? providers : [];
     const deeplinkUsername = normalizeSearchValue(incomingUsername);
     if (
       deeplinkUsername &&
       normalizedQuery === deeplinkUsername
     ) {
       console.log(
         "[search] deeplink exact attempt",
         deeplinkUsername
       );
       const exact = providerList.filter((p) => {
         const u1 = normalizeSearchValue(p.username);
         const u2 = normalizeSearchValue(p.user?.username);
         return u1 === deeplinkUsername || u2 === deeplinkUsername;
       });
       console.log(
         "[search] deeplink exact username",
         deeplinkUsername,
         "matches",
         exact.length
       );
       if (exact.length > 0) {
@@ -3201,51 +3215,51 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
 
     // distance filter
     if (radiusKm > 0) {
       if (!clientLocation) {
         setLocationError(
           "Turn on location services to filter providers by distance."
         );
       } else {
         setLocationError("");
         list = list.filter(
           (p) =>
             typeof p.distance_km === "number" &&
             p.distance_km <= radiusKm
         );
         list.sort((a, b) => {
           const da = a.distance_km ?? 999999;
           const db = b.distance_km ?? 999999;
           return da - db;
         });
       }
     } else {
       setLocationError("");
     }
 
     setFilteredProviders(list);
-  }, [providers, searchQuery, radiusKm, clientLocation, hasSearched, route?.params?.provider]);
+  }, [providers, searchQuery, radiusKm, clientLocation, hasSearched, route?.params?.provider, clearSelectedProvider]);
 
 
 
   const ensureClientLocation = useCallback(async () => {
     try {
       const { status } = await Location.requestForegroundPermissionsAsync();
       if (status !== "granted") {
         setLocationError(
           "Location permission is required to filter by distance."
         );
         if (showFlash) {
           showFlash(
             "error",
             "Please enable location permission to use distance filters."
           );
         }
         return null;
       }
 
       const loc = await Location.getCurrentPositionAsync({});
       const coords = {
         lat: loc.coords.latitude,
         long: loc.coords.longitude,
       };
       setClientLocation(coords);
@@ -3600,51 +3614,59 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
     }
     return days;
   };
 
   const calendarDays = buildCalendarDays();
 
   const formatTimeLabel = (isoString) => {
     const d = new Date(isoString);
     return d.toLocaleTimeString("en-US", {
       hour: "numeric",
       minute: "2-digit",
     });
   };
 
     return (
       <SafeAreaView style={styles.searchSafeArea}>
         <View style={styles.searchHeader}>
           <Text style={styles.searchHeaderTitle}>Search providers</Text>
           <View style={styles.searchBar}>
             <Ionicons name="search-outline" size={18} color={colors.textMuted} />
             <TextInput
               style={styles.searchInput}
               placeholder="Search by profession or providerâ€¦"
               placeholderTextColor={colors.textSecondary}
               value={searchQuery}
-              onChangeText={setSearchQuery}
+              onChangeText={(value) => {
+                if (!normalizeSearchValue(value)) {
+                  setSearchQuery(value);
+                  setHasSearched(false);
+                  clearSelectedProvider();
+                  return;
+                }
+                setSearchQuery(value);
+              }}
               onSubmitEditing={handleSearchSubmit}
               returnKeyType="search"
             />
           </View>
           <View style={styles.chipsRow}>
             <ScrollView
               horizontal
               showsHorizontalScrollIndicator={false}
               contentContainerStyle={styles.chipsContent}
             >
               {distanceChips.map((km) => {
                 const selected = radiusKm === km;
                 const label = km === 0 ? "Any" : `${km}km`;
                 return (
                   <TouchableOpacity
                     key={km}
                     style={[
                       styles.filterChip,
                       selected && styles.filterChipSelected,
                     ]}
                     onPress={() => handleRadiusChange(km)}
                   >
                     <Text
                       style={[
                         styles.filterChipText,
 
EOF
)