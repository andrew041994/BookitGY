 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 437042de73e3c1777e95c791918a85a3ab4bcf96..95f773002a23e69303c16b55c24443fa147868d9 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -5064,51 +5064,57 @@ function ProviderBillingScreen({ token, showFlash }) {
   };
 
   const formatMoney = (value) => {
     const amount = Number.isFinite(value) ? value : 0;
     return `GYD ${Math.round(amount).toLocaleString()}`;
   };
 
   const formatDate = (value) => {
     if (!value) return "-";
     const dateObj = value instanceof Date ? value : new Date(value);
     if (Number.isNaN(dateObj.getTime())) return "-";
     return dateObj.toLocaleDateString("en-US", {
       month: "short",
       day: "numeric",
       year: "numeric",
     });
   };
 
   const normalizeStart = (booking) => {
     const raw = booking?.start_time || booking?.start;
     if (!raw) return null;
     const dateObj = new Date(raw);
     return Number.isNaN(dateObj.getTime()) ? null : dateObj;
   };
 
-  const buildBills = useCallback((bookingList, chargePct = 10, creditBalance = 0) => {
+  const buildBills = useCallback(
+    (
+      bookingList,
+      chargePct = 10,
+      creditBalance = 0,
+      currentMonthDueOverride = null
+    ) => {
     const now = new Date();
     const statements = [];
     const monthsToShow = 6;
 
     const feeRate = Math.max(chargePct, 0) / 100;
     let remainingCredits = Math.max(Number(creditBalance) || 0, 0);
 
     for (let i = 0; i < monthsToShow; i += 1) {
       const coverageStart = new Date(now.getFullYear(), now.getMonth() - i, 1);
       const coverageEnd = new Date(now.getFullYear(), now.getMonth() - i + 1, 0);
       const invoiceDate = new Date(
         coverageStart.getFullYear(),
         coverageStart.getMonth() + 1,
         1
       );
 
       const monthBookings = bookingList.filter((booking) => {
         const start = normalizeStart(booking);
         if (!start) return false;
         return start >= coverageStart && start <= coverageEnd;
       });
 
       const lineItems = monthBookings.length
         ? monthBookings.map((booking) => ({
             bookingId: booking.id || booking.booking_id,
@@ -5124,54 +5130,65 @@ function ProviderBillingScreen({ token, showFlash }) {
               Number(
                 booking.service_price_gyd ??
                   booking.price_gyd ??
                   booking.total_price_gyd ??
                   booking.price
               ) || 0,
           }))
         : [
             {
               bookingId: `empty-${coverageStart.toISOString()}`,
               description: "No completed bookings recorded",
               client: "",
               date: null,
               amount: 0,
             },
           ];
 
       const servicesTotal = lineItems.reduce(
         (sum, item) => sum + (Number.isFinite(item.amount) ? item.amount : 0),
         0
       );
 
         const platformFee = Math.max(Math.round(servicesTotal * feeRate), 0);
         const statementId = `${coverageStart.getFullYear()}-${coverageStart.getMonth() + 1}`;
 
-        const billCreditsApplied = Math.min(remainingCredits, platformFee);
+        let billCreditsApplied = Math.min(remainingCredits, platformFee);
       remainingCredits -= billCreditsApplied;
 
-      const totalDue = Math.max(platformFee - billCreditsApplied, 0);
+      let totalDue = Math.max(platformFee - billCreditsApplied, 0);
+
+      // Always mirror the backend-calculated amount for the current month so
+      // the provider's bill matches the admin dashboard.
+      if (i === 0 && Number.isFinite(currentMonthDueOverride)) {
+        totalDue = Math.max(Number(currentMonthDueOverride) || 0, 0);
+        billCreditsApplied = Math.min(
+          platformFee,
+          Math.max(platformFee - totalDue, 0)
+        );
+        remainingCredits = Math.max(remainingCredits - billCreditsApplied, 0);
+      }
 
       statements.push({
         id: statementId,
         coverageStart,
         coverageEnd,
         invoiceDate,
         status: invoiceDate <= now ? "Generated" : "Scheduled",
         servicesTotal,
         platformFee,
         billCreditsApplied,
         totalDue,
         lineItems,
       });
     }
 
     statements.sort((a, b) => b.invoiceDate - a.invoiceDate);
     setBills(statements);
   }, []);
 
   const fetchBilling = useCallback(async () => {
     try {
       setBillingLoading(true);
       setBillingError("");
 
       const storedToken = await AsyncStorage.getItem("accessToken");
@@ -5186,51 +5203,52 @@ function ProviderBillingScreen({ token, showFlash }) {
         axios.get(`${API}/providers/me/bookings`, {
           headers: { Authorization: `Bearer ${authToken}` },
         }),
         axios
           .get(`${API}/providers/me/summary`, {
             headers: { Authorization: `Bearer ${authToken}` },
           })
           .catch(() => null),
       ]);
 
       const bookingList = Array.isArray(bookingsRes.data)
         ? bookingsRes.data
         : bookingsRes.data?.bookings || bookingsRes.data?.results || [];
 
       const summaryData = summaryRes?.data || null;
       setBillingSummary(summaryData);
 
       const creditBalance = Math.max(
         Number(summaryData?.total_credit_balance_gyd) || 0,
         0
       );
 
       const resolvedChargePct = resolveServiceChargePct(summaryData);
       setServiceChargePct(resolvedChargePct);
 
-      buildBills(bookingList, resolvedChargePct, creditBalance);
+      const netDue = Number(summaryData?.total_fees_due_gyd);
+      buildBills(bookingList, resolvedChargePct, creditBalance, netDue);
     } catch (err) {
       console.log("Error loading billing", err.response?.data || err.message);
       setBillingError("Could not load billing statements.");
       if (showFlash) {
         showFlash("error", "Could not load billing statements.");
       }
     } finally {
       setBillingLoading(false);
     }
   }, [buildBills, showFlash, token?.token]);
 
   useEffect(() => {
     fetchBilling();
   }, [fetchBilling]);
 
   useFocusEffect(
     useCallback(() => {
       fetchBilling();
       return () => {};
     }, [fetchBilling])
   );
 
   const handleRefresh = useCallback(async () => {
     setRefreshing(true);
     await fetchBilling();
 
EOF
)