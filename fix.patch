 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/crud.py b/backend/app/crud.py
index be03bf21322e60e539087ed2f36213b144ae7414..f43917f43d1d2e1e6e99dfd119d5e9a3837e2bd6 100644
--- a/backend/app/crud.py
+++ b/backend/app/crud.py
@@ -429,50 +429,70 @@ def get_promotion(db: Session, provider_id: int):
         .filter(models.Promotion.provider_id == provider_id)
         .first()
     )
 
 
 def upsert_promotion(db: Session, provider_id: int, free_total: int):
     promo = get_promotion(db, provider_id)
     if promo:
         promo.free_bookings_total = free_total
         # Ensure used count isn't above new total
         if free_total < promo.free_bookings_used:
             promo.free_bookings_used = free_total
     else:
         promo = models.Promotion(
             provider_id=provider_id,
             free_bookings_total=free_total,
             free_bookings_used=0,
         )
         db.add(promo)
 
     db.commit()
     db.refresh(promo)
     return promo
 
 
+def create_bill_credit(db: Session, provider_id: int, amount_gyd: float):
+    credit = models.BillCredit(
+        provider_id=provider_id,
+        amount_gyd=Decimal(str(amount_gyd or 0)),
+    )
+    db.add(credit)
+    db.commit()
+    db.refresh(credit)
+    return credit
+
+
+def get_provider_credit_balance(db: Session, provider_id: int) -> float:
+    total = (
+        db.query(func.coalesce(func.sum(models.BillCredit.amount_gyd), 0))
+        .filter(models.BillCredit.provider_id == provider_id)
+        .scalar()
+    )
+    return float(total or 0.0)
+
+
 # ---------------------------------------------------------------------------
 # Booking with promotion + lock check
 # ---------------------------------------------------------------------------
 
 def create_booking(
     db: Session,
     customer_id: int,
     booking: schemas.BookingCreate,
 ) -> Optional[models.Booking]:
     """
     Create a new booking for a customer.
 
     Flow:
     1. Validate service / provider.
     2. Validate that the selected slot is not already booked.
     3. Create booking (confirmed).
     4. Dispatch notifications (single helper).
     """
 
     # Load service
     service = (
         db.query(models.Service)
         .filter(models.Service.id == booking.service_id)
         .first()
     )
@@ -668,59 +688,65 @@ def generate_monthly_bills(db: Session, month: date):
 
             existing_bill.total_gyd = total
             existing_bill.fee_gyd = fee
             existing_bill.due_date = due
         else:
             bill = models.Bill(
                 provider_id=prov.id,
                 month=start,
                 total_gyd=total,
                 fee_gyd=fee,
                 due_date=due,
             )
             db.add(bill)
 
     db.commit()
 
 
 
 
 
 def get_provider_fees_due(db: Session, provider_id: int) -> float:
     """
     Sum of all unpaid fees for this provider, in GYD.
     Assumes Bill.fee_gyd is only populated after appointments have finished.
     """
-    total = (
+    total_fees = (
         db.query(func.coalesce(func.sum(models.Bill.fee_gyd), 0))
         .filter(
             models.Bill.provider_id == provider_id,
             models.Bill.is_paid == False,  # unpaid only
         )
         .scalar()
     )
-    return float(total or 0.0)
+    credits = get_provider_credit_balance(db, provider_id)
+
+    net_due = Decimal(str(total_fees or 0)) - Decimal(str(credits or 0))
+    if net_due < 0:
+        net_due = Decimal("0")
+
+    return float(net_due)
 
 
 def list_bookings_for_provider(db: Session, provider_id: int):
     """Return upcoming bookings for this provider (from now onwards)."""
     now = datetime.utcnow()
 
     rows = (
         db.query(
             models.Booking.id,
             models.Booking.start_time,
             models.Booking.end_time,
             models.Booking.status,
             models.Service.name.label("service_name"),
             models.Service.price_gyd.label("service_price_gyd"),
             models.User.full_name.label("customer_name"),
             
         )
         .join(models.Service, models.Booking.service_id == models.Service.id)
         .join(models.Provider, models.Service.provider_id == models.Provider.id)
         .join(models.User, models.Booking.customer_id == models.User.id)
         .filter(
             models.Provider.id == provider_id,
             models.Booking.start_time >= now,
         )
         .order_by(models.Booking.start_time.asc())
 
EOF
)