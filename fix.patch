 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 29187ec5f2e81cf14620600e11f0e044653181d9..96cb54705a98c1337d88d29b4a8bbd6d629892f6 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -69,130 +69,135 @@ const getProviderUsernameFromPath = (path) => {
   if (!trimmed) return null;
 
   const [firstSegment, secondSegment] = trimmed.split("/");
   if (firstSegment !== "p" || !secondSegment) return null;
 
   try {
     return decodeURIComponent(secondSegment);
   } catch (error) {
     return secondSegment;
   }
 };
 
 const getProviderUsernameFromUrl = (url) => {
   const safeUrl = handleIncomingURL(url);
   if (!safeUrl) return null;
 
   try {
     const parsed = new URL(safeUrl);
     return getProviderUsernameFromPath(parsed.pathname);
   } catch (error) {
     console.log("[deepLinking] Failed to parse URL", safeUrl, error?.message || error);
     return null;
   }
 };
 
+const withTimeout = (promise, ms, label) => {
+  let timeoutId;
+  const timeout = new Promise((_, reject) => {
+    timeoutId = setTimeout(() => {
+      const error = new Error(`${label || "Operation"} timed out after ${ms}ms`);
+      error.code = "ETIMEDOUT";
+      reject(error);
+    }, ms);
+  });
+
+  return Promise.race([promise, timeout]).finally(() => {
+    clearTimeout(timeoutId);
+  });
+};
+
 const createLinkingConfig = ({ isProvider }) => ({
   prefixes: ["https://bookitgy.com", "https://www.bookitgy.com", "bookitgy://"],
   config: {
     screens: {
       Home: "",
       Search: "search",
       PublicProfile: "public-profile/:username",
       Appointments: "appointments",
       Profile: "profile",
       Dashboard: "dashboard",
       Billing: "billing",
     },
   },
   getStateFromPath: (path, options) => {
     try {
       const trimmed = path?.replace(/^\//, "") || "";
       const firstSegment = trimmed.split("/")[0];
 
       if (RESERVED_USERNAME_PATHS.has(firstSegment)) {
         return defaultGetStateFromPath("/profile", options);
       }
 
       const username = getProviderUsernameFromPath(path);
       if (username) {
         const targetPath = isProvider
           ? `/public-profile/${encodeURIComponent(username)}`
           : `/search?username=${encodeURIComponent(username)}`;
         return defaultGetStateFromPath(targetPath, options);
       }
 
       return defaultGetStateFromPath(path, options);
     } catch (error) {
       console.log("[deepLinking] Failed to parse path", path, error?.message || error);
       return undefined;
     }
   },
   async getInitialURL() {
-    const url = await Linking.getInitialURL();
-    return handleIncomingURL(url);
+    try {
+      const url = await withTimeout(Linking.getInitialURL(), 1500, "getInitialURL");
+      return handleIncomingURL(url);
+    } catch (error) {
+      console.log("[deepLinking] Failed to get initial URL", error?.message || error);
+      return null;
+    }
   },
   subscribe(listener) {
     const onReceiveURL = ({ url }) => {
       const safeUrl = handleIncomingURL(url);
       if (safeUrl) listener(safeUrl);
     };
 
     const subscription = Linking.addEventListener("url", onReceiveURL);
     return () => subscription.remove();
   },
 });
 
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
 const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
-const withTimeout = (promise, ms, label) => {
-  let timeoutId;
-  const timeout = new Promise((_, reject) => {
-    timeoutId = setTimeout(() => {
-      const error = new Error(`${label || "Operation"} timed out after ${ms}ms`);
-      error.code = "ETIMEDOUT";
-      reject(error);
-    }, ms);
-  });
-
-  return Promise.race([promise, timeout]).finally(() => {
-    clearTimeout(timeoutId);
-  });
-};
-
 const LEGACY_ACCESS_TOKEN_KEY = "accessToken";
 
 const getAuthToken = async (tokenState) => {
   if (tokenState?.token) return tokenState.token;
 
   try {
     const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY);
     return legacy || null;
   } catch (error) {
     console.log("[auth] Failed to load legacy token", error?.message || error);
     return null;
   }
 };
 
 const FAVORITES_STORAGE_KEY = (userKey) =>
   userKey ? `favoriteProviders:${userKey}` : "favoriteProviders";
 
 const getProviderId = (provider) =>
@@ -6104,50 +6109,63 @@ function App() {
               await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
               if (isActive) setToken(null);
             } else if (isActive) {
               setToken({ token: restoredToken });
             }
           }
         }
       } catch (err) {
         console.log(
           "[auth] Failed to restore session",
           err?.message || err
         );
         if (isActive) setToken(null);
       } finally {
         if (isActive) setAuthLoading(false);
       }
     };
 
     restoreSession();
 
     return () => {
       isActive = false;
     };
   }, []);
 
+  useEffect(() => {
+    if (!authLoading) return undefined;
+
+    const watchdog = setTimeout(() => {
+      if (authLoading) {
+        console.log("[auth] authLoading watchdog timeout");
+        setAuthLoading(false);
+      }
+    }, 15000);
+
+    return () => clearTimeout(watchdog);
+  }, [authLoading]);
+
   useEffect(() => {
     console.log("[auth] authLoading:", authLoading);
   }, [authLoading]);
 
   useEffect(() => {
     if (!token) {
       setIsNavReady(false);
     }
   }, [token]);
 
   useEffect(() => {
     if (token) return undefined;
     let isActive = true;
 
     const handleInitialUrl = async () => {
       const initialUrl = await Linking.getInitialURL();
       if (!isActive) return;
 
       const username = getProviderUsernameFromUrl(initialUrl);
       if (username) setPendingDeepLinkUsername(username);
     };
 
     handleInitialUrl();
 
     const subscription = Linking.addEventListener("url", ({ url }) => {
 
EOF
)