 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 34cf9d06f9804b2e35756d67a022890b5b397d0b..643be10e05da52da5210daf40bab7559b1e4907e 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -134,57 +134,51 @@ const createLinkingConfig = ({ isProvider }) => ({
   subscribe(listener) {
     const onReceiveURL = ({ url }) => {
       const safeUrl = handleIncomingURL(url);
       if (safeUrl) listener(safeUrl);
     };
 
     const subscription = Linking.addEventListener("url", onReceiveURL);
     return () => subscription.remove();
   },
 });
 
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
   const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
-const getAuthToken = async (tokenState) => {
-  if (tokenState?.token) return tokenState.token;
-  const secureToken = await loadToken();
-  if (secureToken) return secureToken;
-  const legacyToken = await AsyncStorage.getItem("accessToken");
-  return legacyToken || null;
-};
+const getAuthToken = async (tokenState) => tokenState?.token || null;
 
 const FAVORITES_STORAGE_KEY = (userKey) =>
   userKey ? `favoriteProviders:${userKey}` : "favoriteProviders";
 
 const getProviderId = (provider) =>
   provider?.provider_id ?? provider?.id ?? provider?._id ?? null;
 
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
 
   const persistIds = useCallback(async (ids) => {
     try {
       await AsyncStorage.setItem(storageKey, JSON.stringify(ids));
     } catch (err) {
       console.log("Error saving favorites", err?.message || err);
     }
   }, [storageKey]);
 
   const loadFavoritesFromStorage = useCallback(async () => {
     try {
       setFavoritesLoading(true);
       const raw = await AsyncStorage.getItem(storageKey);
@@ -396,52 +390,52 @@ function LoginScreen({
     if (!trimmedEmail || !isValidEmail(trimmedEmail)) {
       if (showFlash) {
         showFlash("error", "Please enter a valid email address");
       } else {
         Alert.alert("Error", "Please enter a valid email address");
       }
       return;
   }
 
   setLoading(true);
 
     try {
       const body = new URLSearchParams({
         username: normalizedEmail,
         password: password,
       }).toString();
 
     const res = await axios.post(`${API}/auth/login`, body, {
         headers: {
           "Content-Type": "application/x-www-form-urlencoded",
         },
       });
 
     try {
       await saveToken(res.data.access_token);
-      await AsyncStorage.setItem("accessToken", res.data.access_token);
       const persistedToken = await loadToken();
+      console.log("[auth] login success -> token saved:", Boolean(persistedToken));
       if (!persistedToken) {
         Alert.alert(
           "Save issue",
           "We couldn't save your login securely. You'll stay logged in for now."
         );
       }
     } catch (err) {
       console.error(
         "[LOGIN_NATIVE_CRASH_GUARD] Failed to persist access token",
         err
       );
       Sentry.Native.captureException(err, {
         extra: { scope: "token-persistence" },
       });
       Alert.alert(
         "Save issue",
         "We couldn't save your login securely. You'll stay logged in for now."
       );
     }
 
     // Successful login
       // Successful login
       setToken({
         token: res.data.access_token,
         userId: res.data.user_id,
@@ -5928,146 +5922,217 @@ function FlashMessage({ flash }) {
 
   const backgroundColor = isError ? "#fee2e2" : "#dcfce7"; // red / green
   const borderColor = isError ? "#b91c1c" : "#16a34a";
   const textColor = isError ? "#7f1d1d" : "#166534";
 
   return (
 
     <View
       style={[
         styles.flashContainer,
         { backgroundColor, borderColor },
       ]}
     >
       <Text style={[styles.flashText, { color: textColor }]}>
         {flash.text}
       </Text>
     </View>
   );
 }
 
 
 // ðŸ”¹ App orchestrates landing/login/signup/forgot-password vs main app
 
 function App() {
   const [token, setToken] = useState(null);
+  const [authLoading, setAuthLoading] = useState(true);
   const [authMode, setAuthMode] = useState("landing"); // 'landing' | 'login' | 'signup' | 'forgot'
   const [isAdmin, setIsAdmin] = useState(false);
   const navigationRef = useRef(null);
   const [isNavReady, setIsNavReady] = useState(false);
   const [pendingDeepLinkUsername, setPendingDeepLinkUsername] = useState(null);
 
   const [flash, setFlash] = useState(null);
 
   const formatFlashText = (text) => {
     if (typeof text === "string") return text;
     if (text == null) return "Something went wrong.";
 
     const formatErrorItem = (item) => {
       if (typeof item === "string") return item;
       if (!item || typeof item !== "object") return String(item);
 
       const message = item.msg || item.message;
       if (Array.isArray(item.loc) && item.loc.length > 0) {
         const field = item.loc[item.loc.length - 1];
         return message ? `${field}: ${message}` : String(item);
       }
       if (message) return message;
       return JSON.stringify(item);
     };
 
     if (Array.isArray(text)) {
       return text.map(formatErrorItem).filter(Boolean).join("\n");
     }
 
     if (typeof text === "object") {
       if (Array.isArray(text.detail)) {
         return formatFlashText(text.detail);
       }
       if (typeof text.detail === "string") return text.detail;
       if (typeof text.message === "string") return text.message;
       if (typeof text.msg === "string") return text.msg;
       return JSON.stringify(text);
     }
 
     return String(text);
   };
 
   const showFlash = (type, text) => {
     setFlash({ type, text: formatFlashText(text) });
     setTimeout(() => {
       setFlash(null);
     }, 3000);
   };
 
+  useEffect(() => {
+    let isActive = true;
+    const restoreSession = async () => {
+      try {
+        const restoredToken = await loadToken();
+        console.log("[auth] token loaded:", Boolean(restoredToken));
+
+        if (!restoredToken) {
+          if (isActive) setToken(null);
+          return;
+        }
+
+        try {
+          const meRes = await axios.get(`${API}/users/me`, {
+            headers: {
+              Authorization: `Bearer ${restoredToken}`,
+            },
+          });
+          if (!isActive) return;
+          setToken({
+            token: restoredToken,
+            userId: meRes.data?.id || meRes.data?.user_id,
+            email: meRes.data?.email,
+            isProvider: Boolean(meRes.data?.is_provider),
+            isAdmin: Boolean(meRes.data?.is_admin),
+          });
+          setIsAdmin(Boolean(meRes.data?.is_admin));
+        } catch (err) {
+          console.log(
+            "[auth] Failed to load user info during bootstrap",
+            err?.message || err
+          );
+          if (isActive) setToken({ token: restoredToken });
+        }
+      } catch (err) {
+        console.log(
+          "[auth] Failed to restore session",
+          err?.message || err
+        );
+        if (isActive) setToken(null);
+      } finally {
+        if (isActive) setAuthLoading(false);
+      }
+    };
+
+    restoreSession();
+
+    return () => {
+      isActive = false;
+    };
+  }, []);
+
+  useEffect(() => {
+    console.log("[auth] authLoading:", authLoading);
+  }, [authLoading]);
+
   useEffect(() => {
     if (!token) {
       setIsNavReady(false);
     }
   }, [token]);
 
   useEffect(() => {
     if (token) return undefined;
     let isActive = true;
 
     const handleInitialUrl = async () => {
       const initialUrl = await Linking.getInitialURL();
       if (!isActive) return;
 
       const username = getProviderUsernameFromUrl(initialUrl);
       if (username) setPendingDeepLinkUsername(username);
     };
 
     handleInitialUrl();
 
     const subscription = Linking.addEventListener("url", ({ url }) => {
       if (!isActive) return;
       const username = getProviderUsernameFromUrl(url);
       if (username) setPendingDeepLinkUsername(username);
     });
 
     return () => {
       isActive = false;
       subscription.remove();
     };
   }, [token]);
 
   useEffect(() => {
     if (!pendingDeepLinkUsername || !token || !isNavReady) return;
     if (!navigationRef.current) return;
 
     const targetRoute = token?.isProvider ? "PublicProfile" : "Search";
     try {
       navigationRef.current.navigate(targetRoute, {
         username: pendingDeepLinkUsername,
       });
       setPendingDeepLinkUsername(null);
     } catch (error) {
       console.log("[deepLinking] Failed to navigate", error?.message || error);
     }
   }, [pendingDeepLinkUsername, token, isNavReady]);
 
+  if (authLoading) {
+    return (
+      <SafeAreaProvider>
+        <SafeAreaView style={{ flex: 1 }} edges={["top", "bottom"]}>
+          <FlashMessage flash={flash} />
+          <View style={styles.center}>
+            <ActivityIndicator size="large" color="#0B6BF2" />
+            <Text style={styles.loadingText}>Loading BookitGYâ€¦</Text>
+          </View>
+        </SafeAreaView>
+      </SafeAreaProvider>
+    );
+  }
+
   return (
     <SafeAreaProvider>
       <SafeAreaView style={{ flex: 1 }} edges={["top", "bottom"]}>
         <FlashMessage flash={flash} />
 
         {!token ? (
           <>
             {authMode === "landing" && (
               <LandingScreen
                 goToLogin={() => setAuthMode("login")}
                 goToSignup={() => setAuthMode("signup")}
               />
             )}
 
             {authMode === "login" && (
               <LoginScreen
                 setToken={setToken}
                 setIsAdmin={setIsAdmin}
                 goToSignup={() => setAuthMode("signup")}
                 goToForgot={() => setAuthMode("forgot")}
                 goBack={() => setAuthMode("landing")}
                 showFlash={showFlash}
               />
             )}
 
 
EOF
)