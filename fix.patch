 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index bbb156b958bcfc5b5900fda81f157ac4a5e61863..8471e8dc2a047cdbbf33b6d9ed1a5231f1387f79 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -1,110 +1,236 @@
 import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
-import { createApiClient } from "./src/api/client";
-import { apiClient } from "./src/api";
 
 import {
   Text,
   View,
   StyleSheet,
   TextInput,
   Button,
   Alert,
   ActivityIndicator,
   ScrollView,
   TouchableOpacity,
   Switch,
   Linking,
   Platform,
   Image,
   KeyboardAvoidingView,
   TouchableWithoutFeedback,
   Keyboard,
   Pressable,
   RefreshControl,
   Share,
   Modal,
   FlatList,
 } from "react-native";
 import * as ExpoLinking from "expo-linking";
 import {
   NavigationContainer,
   CommonActions,
   useFocusEffect,
   useIsFocused,
 } from "@react-navigation/native";
 import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
 import { enableScreens } from "react-native-screens";
 import axios from "axios";
 import AsyncStorage from "@react-native-async-storage/async-storage";
 import {
   clearToken,
   clearAllAuthTokens,
+  loadRefreshToken,
   loadToken,
   saveRefreshToken,
   saveToken,
 } from "./src/components/tokenStorage";
 import ProviderCard from "./src/components/ProviderCard";
 import * as Location from "expo-location";
 import Constants from "expo-constants";
 import * as ImagePicker from "expo-image-picker";
 import { Ionicons } from "@expo/vector-icons";
 import {
   CalendarProvider,
   Calendar,
 } from "react-native-calendars";
 import {
   SafeAreaProvider,
   SafeAreaView,
   useSafeAreaInsets,
 } from "react-native-safe-area-context";
 // import { AccessToken, LoginManager } from "react-native-fbsdk-next";
 import BookitGYLogoTransparent from "./assets/bookitgy-logo-transparent.png"
 import { theme } from "./src/theme";
 // import * as Sentry from "sentry-expo";
 
 let Clipboard = null;
 try {
   Clipboard = require("expo-clipboard");
 } catch (e) {}
 
 enableScreens(false);
 
 
 
 
 // import { API } from "./App"; // wherever you define your base URL
 
 
 
 
 
 const API =
   Constants.expoConfig?.extra?.API_URL ||
   Constants.manifest?.extra?.API_URL ||
   "https://bookitgy.onrender.com";
 
+const api = axios.create({ baseURL: API });
+const refreshApi = axios.create({ baseURL: API });
+
+let accessTokenInMemory = null;
+let refreshPromise = null;
+let onApiUnauthorized = null;
+
+const setApiUnauthorizedHandler = (handler) => {
+  onApiUnauthorized = handler;
+};
+
+const setApiAccessToken = (accessToken) => {
+  accessTokenInMemory = accessToken || null;
+
+  if (accessToken) {
+    api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
+    return;
+  }
+
+  delete api.defaults.headers.common.Authorization;
+};
+
+const loadAccessTokenForRequest = async () => {
+  if (accessTokenInMemory) return accessTokenInMemory;
+
+  const storedToken = await loadToken();
+  if (storedToken) {
+    setApiAccessToken(storedToken);
+    return storedToken;
+  }
+
+  const legacyToken = await AsyncStorage.getItem("accessToken");
+  if (legacyToken) {
+    setApiAccessToken(legacyToken);
+    return legacyToken;
+  }
+
+  setApiAccessToken(null);
+  return null;
+};
+
+const refreshAccessToken = async () => {
+  const storedRefreshToken = await loadRefreshToken();
+  if (!storedRefreshToken) {
+    const missingRefreshError = new Error("Missing refresh token");
+    missingRefreshError.code = "SESSION_EXPIRED";
+    throw missingRefreshError;
+  }
+
+  const response = await refreshApi.post("/auth/refresh", {
+    refresh_token: storedRefreshToken,
+  });
+
+  const newAccessToken = response?.data?.access_token;
+  const newRefreshToken = response?.data?.refresh_token || storedRefreshToken;
+
+  if (!newAccessToken) {
+    const invalidRefreshError = new Error("Invalid refresh response");
+    invalidRefreshError.code = "SESSION_EXPIRED";
+    throw invalidRefreshError;
+  }
+
+  await saveToken(newAccessToken);
+  await saveRefreshToken(newRefreshToken);
+  setApiAccessToken(newAccessToken);
+  return newAccessToken;
+};
+
+api.interceptors.request.use(async (config) => {
+  const latestToken = await loadAccessTokenForRequest();
+
+  if (latestToken) {
+    config.headers = {
+      ...(config.headers || {}),
+      Authorization: `Bearer ${latestToken}`,
+    };
+  } else if (config.headers?.Authorization) {
+    delete config.headers.Authorization;
+  }
+
+  return config;
+});
+
+api.interceptors.response.use(
+  (response) => response,
+  async (error) => {
+    const originalRequest = error?.config || {};
+    const status = error?.response?.status;
+    const requestUrl = originalRequest?.url || "";
+
+    if (
+      status !== 401 ||
+      originalRequest.__isRetryRequest ||
+      requestUrl.includes("/auth/refresh")
+    ) {
+      return Promise.reject(error);
+    }
+
+    originalRequest.__isRetryRequest = true;
+
+    try {
+      if (!refreshPromise) {
+        refreshPromise = refreshAccessToken().finally(() => {
+          refreshPromise = null;
+        });
+      }
+
+      const nextAccessToken = await refreshPromise;
+      originalRequest.headers = {
+        ...(originalRequest.headers || {}),
+        Authorization: `Bearer ${nextAccessToken}`,
+      };
+
+      return api(originalRequest);
+    } catch (refreshError) {
+      setApiAccessToken(null);
+      await clearAllAuthTokens();
+      await AsyncStorage.removeItem("accessToken");
+      if (typeof onApiUnauthorized === "function") {
+        await onApiUnauthorized(refreshError);
+      }
+      refreshError.isAuthFailure = true;
+      return Promise.reject(refreshError);
+    }
+  }
+);
+
   console.log("### API base URL =", API);
 
 
 const colors = theme.colors;
 const HEADER_LOGO_WIDTH = 120;
 const HEADER_LOGO_HEIGHT = 120;
 const HEADER_VERTICAL_PADDING = 0;
 
 // status color mapping
 const getAppointmentStatusThemeKey = (statusValue) => {
   const normalized = `${statusValue || ""}`.trim().toLowerCase();
   if (normalized.includes("cancel")) return "cancelled";
   if (normalized.includes("complete")) return "completed";
   return "scheduled";
 };
 
 const APPOINTMENT_STATUS_THEME = {
   scheduled: {
     accent: "#4DA3FF",
     bgTint: "rgba(77,163,255,0.10)",
     border: "rgba(77,163,255,0.35)",
   },
   completed: {
     accent: "#2ECC71",
     bgTint: "rgba(46,204,113,0.10)",
@@ -139,56 +265,55 @@ const FB_COMPLETE_ERROR_MESSAGES = {
   EMAIL_REQUIRED: "Please provide an email address to continue.",
   PHONE_REQUIRED: "Please provide your phone number to continue.",
   PHONE_TAKEN: "This phone number is already in use.",
   FB_TOKEN_INVALID: "Facebook login session expired. Please try again.",
 };
 
 const normalizeErrorCode = (payload) => {
   if (!payload) return null;
   const detailCode = payload?.detail?.code;
   if (typeof detailCode === "string") return detailCode;
   if (typeof payload?.code === "string") return payload.code;
   if (typeof payload?.detail === "string") return payload.detail;
   return null;
 };
 
 const getFacebookCompleteErrorMessage = (code) =>
   FB_COMPLETE_ERROR_MESSAGES[code] || "Unable to complete Facebook login. Please try again.";
 
 const persistFacebookSession = async ({
   responseData,
   setToken,
   setIsAdmin,
 }) => {
   await saveToken(responseData.access_token);
   await saveRefreshToken(responseData.refresh_token);
+  setApiAccessToken(responseData.access_token);
 
   let meData = null;
   try {
-    const meRes = await axios.get(`${API}/users/me`, {
-      headers: { Authorization: `Bearer ${responseData.access_token}` },
-    });
+    const meRes = await api.get(`/users/me`);
     meData = meRes.data;
   } catch (meError) {
     console.log("[auth] Failed to fetch /users/me after Facebook login", meError?.message || meError);
   }
 
   setToken({
     token: responseData.access_token,
     userId: meData?.id || meData?.user_id || responseData.user_id,
     email: meData?.email || responseData.email,
     username: meData?.username,
     isProvider:
       typeof meData?.is_provider === "boolean"
         ? meData?.is_provider
         : responseData.is_provider,
     isAdmin:
       typeof meData?.is_admin === "boolean" ? meData?.is_admin : responseData.is_admin,
   });
 
   setIsAdmin(
     typeof meData?.is_admin === "boolean" ? meData?.is_admin : !!responseData.is_admin
   );
 };
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
@@ -471,51 +596,51 @@ function useFavoriteProviders(userKey) {
         const idSet = new Set(favoriteIds);
         const merged = list.filter((p) => idSet.has(getProviderId(p)));
 
         const prevMap = new Map(
           prev.map((p) => [getProviderId(p), p]).filter(([id]) => idSet.has(id))
         );
 
         merged.forEach((p) => {
           const id = getProviderId(p);
           if (id) prevMap.set(id, p);
         });
 
         return Array.from(prevMap.values());
       });
     },
     [favoriteIds]
   );
 
   const refreshFavoriteProviders = useCallback(async () => {
     if (!favoriteIds.length) {
       setFavoriteProviders([]);
       return;
     }
 
     try {
-      const res = await axios.get(`${API}/providers`);
+      const res = await api.get(`/providers`);
       const list = Array.isArray(res.data)
         ? res.data
         : res.data?.providers || [];
 
       const idSet = new Set(favoriteIds);
       setFavoriteProviders(list.filter((p) => idSet.has(getProviderId(p))));
     } catch (err) {
       console.log(
         "Error refreshing favorite providers",
         err?.response?.data || err?.message
       );
     }
   }, [favoriteIds]);
 
   useEffect(() => {
     if (favoritesLoading) return;
     refreshFavoriteProviders();
   }, [favoriteIds, favoritesLoading, refreshFavoriteProviders]);
 
   const toggleFavorite = useCallback(
     (provider) => {
       const id = getProviderId(provider);
       if (!id) return;
 
       setFavoriteIds((prev) => {
@@ -656,88 +781,86 @@ function LoginScreen({
   const [loading, setLoading] = useState(false);
   const [facebookLoading, setFacebookLoading] = useState(false);
 
 
   const login = async () => {
     const trimmedEmail = email.trim();
     const normalizedEmail = trimmedEmail.toLowerCase();
 
     if (!trimmedEmail || !isValidEmail(trimmedEmail)) {
       if (showFlash) {
         showFlash("error", "Please enter a valid email address");
       } else {
         Alert.alert("Error", "Please enter a valid email address");
       }
       return;
   }
 
   setLoading(true);
 
     try {
       const body = new URLSearchParams({
         username: normalizedEmail,
         password: password,
       }).toString();
 
-    const res = await axios.post(`${API}/auth/login`, body, {
+    const res = await api.post(`/auth/login`, body, {
         headers: {
           "Content-Type": "application/x-www-form-urlencoded",
         },
       });
 
+    setApiAccessToken(res.data.access_token);
+
     try {
       await saveToken(res.data.access_token);
       await saveRefreshToken(res.data.refresh_token);
       const persistedToken = await loadToken();
       console.log("[auth] login success -> token saved:", Boolean(persistedToken));
       if (!persistedToken) {
         Alert.alert(
           "Save issue",
           "We couldn't save your login securely. You'll stay logged in for now."
         );
       }
     } catch (err) {
       console.error(
         "[LOGIN_NATIVE_CRASH_GUARD] Failed to persist access token",
         err
       );
       // Sentry.Native.captureException(err, {
       //   extra: { scope: "token-persistence" },
       // });
       Alert.alert(
         "Save issue",
         "We couldn't save your login securely. You'll stay logged in for now."
       );
     }
 
     let meData = null;
     try {
-      const meRes = await axios.get(`${API}/users/me`, {
-        headers: {
-          Authorization: `Bearer ${res.data.access_token}`,
-        },
-      });
+      const meRes = await api.get(`/users/me`);
       meData = meRes.data;
     } catch (meError) {
       console.log("[auth] Failed to fetch /users/me after login", meError?.message || meError);
     }
 
     // Successful login
       setToken({
         token: res.data.access_token,
         userId: meData?.id || meData?.user_id || res.data.user_id,
         email: meData?.email || res.data.email,
         username: meData?.username,
         isProvider: typeof meData?.is_provider === "boolean" ? meData?.is_provider : res.data.is_provider,
         isAdmin: typeof meData?.is_admin === "boolean" ? meData?.is_admin : res.data.is_admin,
       });
 
       setIsAdmin(
         typeof meData?.is_admin === "boolean" ? meData?.is_admin : !!res.data.is_admin
       );
 
     if (showFlash) {
         showFlash("success", "Logged in successfully");
       }
     } catch (e) {
       console.log("Login error:", e.response?.data || e.message);
       if (showFlash) {
@@ -756,51 +879,51 @@ function LoginScreen({
     try {
       const loginResult = await LoginManager.logInWithPermissions([
         "public_profile",
         "email",
       ]);
 
       if (loginResult?.isCancelled) {
         return;
       }
 
       const accessTokenData = await AccessToken.getCurrentAccessToken();
       const facebookAccessToken = accessTokenData?.accessToken;
 
       if (!facebookAccessToken) {
         showFlash?.("error", "Could not get Facebook access token. Please try again.");
         return;
       }
 
       const payload = {
         facebook_access_token: facebookAccessToken,
         phone: "",
         is_provider: false,
       };
 
       try {
-        const res = await axios.post(`${API}/auth/facebook/complete`, payload);
+        const res = await api.post(`/auth/facebook/complete`, payload);
         await persistFacebookSession({
           responseData: res.data,
           setToken,
           setIsAdmin,
         });
         showFlash?.("success", "Logged in successfully");
       } catch (requestError) {
         const errorCode = normalizeErrorCode(requestError?.response?.data);
         if (errorCode === "EMAIL_REQUIRED" || errorCode === "PHONE_REQUIRED") {
           onFacebookSetupRequired?.({
             facebookAccessToken,
             requiresEmail: errorCode === "EMAIL_REQUIRED",
             requiresPhone: true,
             initialPhone: "",
             initialEmail: "",
             initialIsProvider: false,
           });
           return;
         }
 
         showFlash?.("error", getFacebookCompleteErrorMessage(errorCode));
       }
     } catch (error) {
       console.log("Facebook login error:", error?.response?.data || error?.message || error);
       showFlash?.("error", "Facebook login failed. Please try again.");
@@ -923,51 +1046,51 @@ return (
       </ScrollView>
     </KeyboardAvoidingView>
   );
 
 }
 
 
 function ForgotPasswordScreen({ goToLogin, goBack, showFlash }) {
   const [email, setEmail] = useState("");
   const [submitting, setSubmitting] = useState(false);
   const [devResetLink, setDevResetLink] = useState(null);
 
   const requestReset = async () => {
     const trimmedEmail = email.trim();
     const normalizedEmail = trimmedEmail.toLowerCase();
 
     if (!trimmedEmail || !isValidEmail(trimmedEmail)) {
       showFlash?.("error", "Please enter a valid email address");
       return;
     }
 
     setSubmitting(true);
     setDevResetLink(null);
 
     try {
-      const res = await axios.post(`${API}/auth/forgot-password`, {
+      const res = await api.post(`/auth/forgot-password`, {
         email: normalizedEmail,
       });
       const message =
         res.data?.message ||
         "If an account exists for that email, a reset link has been sent.";
 
       showFlash?.("success", message);
 
       if (res.data?.reset_link) {
         setDevResetLink(res.data.reset_link);
       }
     } catch (err) {
       console.log("Forgot password error", err?.response?.data || err?.message);
       showFlash?.("error", "Unable to send reset email. Please try again.");
     } finally {
       setSubmitting(false);
     }
   };
 
   return (
     <KeyboardAvoidingView
       style={styles.avoider}
       behavior={Platform.OS === "ios" ? "padding" : "height"}
       keyboardVerticalOffset={Platform.OS === "ios" ? 40 : 0}
     >
@@ -1070,51 +1193,51 @@ function FinishSetupScreen({
       return;
     }
 
     if (requiresEmail && !trimmedEmail) {
       showFlash?.("error", "Email is required.");
       return;
     }
 
     if (trimmedEmail && !isValidEmail(trimmedEmail)) {
       showFlash?.("error", "Please enter a valid email address.");
       return;
     }
 
     setSubmitting(true);
     try {
       const payload = {
         facebook_access_token: facebookSetup?.facebookAccessToken,
         phone: trimmedPhone,
         is_provider: isProvider,
       };
 
       if (trimmedEmail) {
         payload.email = trimmedEmail.toLowerCase();
       }
 
-      const res = await axios.post(`${API}/auth/facebook/complete`, payload);
+      const res = await api.post(`/auth/facebook/complete`, payload);
       await persistFacebookSession({
         responseData: res.data,
         setToken,
         setIsAdmin,
       });
       showFlash?.("success", "Logged in successfully");
     } catch (error) {
       const errorCode = normalizeErrorCode(error?.response?.data);
       showFlash?.("error", getFacebookCompleteErrorMessage(errorCode));
     } finally {
       setSubmitting(false);
     }
   };
 
   return (
     <KeyboardAvoidingView
       style={styles.avoider}
       behavior={Platform.OS === "ios" ? "padding" : "height"}
       keyboardVerticalOffset={Platform.OS === "ios" ? 40 : 0}
     >
       <ScrollView
         contentContainerStyle={styles.scrollContent}
         keyboardShouldPersistTaps="handled"
       >
         <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
@@ -1298,51 +1421,51 @@ function SignupScreen({ goToLogin, goBack, showFlash }) {
     }
 
     // âœ… Normalize phone into WhatsApp format: whatsapp:+...
     let whatsappValue = trimmedPhone;
 
     // Strip existing 'whatsapp:' if user typed it
     if (whatsappValue.startsWith("whatsapp:")) {
       whatsappValue = whatsappValue.replace(/^whatsapp:/, "");
     }
 
     // Ensure it starts with +
     if (!whatsappValue.startsWith("+")) {
       // If it starts with 592, assume +592...
       if (whatsappValue.startsWith("592")) {
         whatsappValue = `+${whatsappValue}`;
       } else {
         // Fallback: just prefix +
         whatsappValue = `+${whatsappValue}`;
       }
     }
 
     // Final WhatsApp format
     whatsappValue = `whatsapp:${whatsappValue}`;
 
     try {
-      await axios.post(`${API}/auth/signup`, {
+      await api.post(`/auth/signup`, {
         email: normalizedEmail,
         password: trimmedPassword,
         username: trimmedUsername,
         phone: trimmedPhone,          // plain phone as user entered
         location: "Georgetown",
         whatsapp: whatsappValue,      // normalized WhatsApp format
         is_provider: isProvider,      // tell backend this is a provider
       });
 
       if (showFlash) {
         showFlash("success", "Account created! Please verify email and log in.");
       } else {
         Alert.alert("Success", "Account created! Please verify email and log in.");
       }
 
       if (goToLogin) goToLogin();
     } catch (e) {
       console.log("Signup error:", e.response?.data || e.message);
       const detail = e.response?.data?.detail || "Signup failed. Try again.";
       if (showFlash) {
         showFlash("error", detail);
       } else {
         Alert.alert("Error", detail);
       }
     }
@@ -1941,55 +2064,51 @@ function ProfileScreen({ apiClient, authLoading, setToken, showFlash, token }) {
         if (showFlash) showFlash("error", "No access token found. Please log in again.");
         return;
       }
 
       const trimmedUsername = String(editProfile.username || "").trim();
       if (trimmedUsername && !isValidUsername(trimmedUsername)) {
         if (showFlash) {
           showFlash(
             "error",
             "Username can only contain letters, numbers, dots, underscores, or dashes (no spaces)."
           );
         }
         return;
       }
 
       const payload = {
         full_name: editProfile.full_name,
         username: trimmedUsername,
         phone: editProfile.phone,
         whatsapp: editProfile.whatsapp,
         location: editProfile.location,
       };
 
       console.log("[profile] save payload", payload);
       console.log("[profile] auth token present", Boolean(storedToken));
-      const res = await apiClient.put("/users/me", payload, {
-        headers: {
-          Authorization: `Bearer ${storedToken}`,
-        },
-      });
+      const res = await apiClient.put("/users/me", payload);
       console.log("[profile] save response status", res?.status);
 
       const meRes = await apiClient.get("/users/me");
       console.log("[profile] refresh response status", meRes?.status);
 
       setUser(meRes.data);
       setEditProfile({
         full_name: meRes.data?.full_name || "",
         username: meRes.data?.username || "",
         phone: meRes.data?.phone || "",
         whatsapp: meRes.data?.whatsapp || "",
         location: meRes.data?.location || "",
       });
       if (setToken) {
         setToken((prev) => ({
           ...(prev || {}),
           email: meRes.data?.email,
           username: meRes.data?.username,
           isProvider: !!meRes.data?.is_provider,
           isAdmin: !!meRes.data?.is_admin,
         }));
       }
 
       if (showFlash) showFlash("success", "Profile updated");
       setShowEdit(false);
@@ -2095,51 +2214,51 @@ function ProfileScreen({ apiClient, authLoading, setToken, showFlash, token }) {
       </View>
     );
   }
 
   const isAdmin = user.is_admin;
   const isProvider = user.is_provider;
   const role = isAdmin ? "Admin" : isProvider ? "Provider" : "Client";
   const hasContactDetails = Boolean(user.phone || user.location);
   const showActivityBookings = !isProvider;
   const toggleMyBookings = async () => {
     const next = !showBookings;
     setShowBookings(next);
     if (next) {
       await loadMyBookings();
     }
   };
 
   const handleClientCancelBooking = (bookingId) => {
   Alert.alert("Cancel booking", "Are you sure you want to cancel this booking?", [
     { text: "No", style: "cancel" },
     {
       text: "Yes, cancel",
       style: "destructive",
       onPress: async () => {
         try {
-          await apiClient.post(`/bookings/${bookingId}/cancel`, {});
+          await apiClient.post(`/bookings/${bookingId}/cancel`);
 
           setBookings((prev) =>
             (prev || []).map((b) =>
               b.id === bookingId ? { ...b, status: "cancelled" } : b
             )
           );
 
           if (showFlash) showFlash("success", "Booking cancelled");
         } catch (err) {
           console.log("Error cancelling booking (client)", err.response?.data || err.message);
           if (showFlash) showFlash("error", "Could not cancel booking.");
         }
       },
     },
   ]);
 };
 
 
   const handleNavigateToBooking = (booking) => {
     try {
       let url = "";
 
       if (
         booking.provider_lat != null &&
         booking.provider_long != null
@@ -2764,51 +2883,51 @@ function ClientHomeScreen({
       try {
         const fresh = await Location.getCurrentPositionAsync({
           accuracy: Location.Accuracy.Balanced,
           timeout: 2000,
         });
         if (fresh?.coords?.latitude != null && fresh?.coords?.longitude != null) {
           coords = { lat: toNum(fresh.coords.latitude), long: toNum(fresh.coords.longitude) };
         }
       } catch {}
     }
 
     if (!coords?.lat || !coords?.long) {
       setNearbyError("Could not determine your location.");
       setNearbyProviders([]);
       setCurrentProvider(null);
       return;
     }
 
     // Store + set location (fast)
     setClientLocation(coords);
     AsyncStorage.setItem("clientLocation", JSON.stringify(coords)).catch(() => {});
 
     // 2) Fetch providers NOW (donâ€™t wait on long GPS)
     const clientCoords = { lat: coords.lat, lng: coords.long };
 
-    const res = await axios.get(`${API}/providers`, { timeout: 8000 });
+    const res = await api.get(`/providers`, { timeout: 8000 });
     const list = Array.isArray(res.data) ? res.data : res.data?.providers || [];
 
     // 3) Compute + sort (keep it cheap)
     const withinRadius = [];
     for (const p of list) {
       const pc = getProviderCoords(p);
       if (!pc) continue;
 
       const d = haversineKm(clientCoords.lat, clientCoords.lng, pc.lat, pc.lng);
       if (!Number.isFinite(d) || d > 15) continue;
 
       withinRadius.push({ ...p, distance_km: d });
     }
     withinRadius.sort((a, b) => (a.distance_km ?? Infinity) - (b.distance_km ?? Infinity));
 
     setNearbyProviders(withinRadius);
     setCurrentProvider(withinRadius[0] || null);
 
     // IMPORTANT: donâ€™t make home wait on favorites syncing
     Promise.resolve()
       .then(() => syncFavoritesFromList(withinRadius))
       .catch(() => {});
 
   } catch (err) {
     console.log("Error loading nearby providers", err?.response?.data || err?.message);
@@ -2826,51 +2945,51 @@ function ClientHomeScreen({
   //     setNearbyLoading(true);
   //     setNearbyError("");
   //     setLocationDenied(false);
 
   //     const { status } = await Location.requestForegroundPermissionsAsync();
   //     if (status !== "granted") {
   //       setLocationDenied(true);
   //       setClientLocation(null);
   //       setNearbyProviders([]);
   //       setCurrentProvider(null);
   //       return;
   //     }
 
   //     const loc = await Location.getCurrentPositionAsync({});
   //     const coords = {
   //       lat: toNum(loc.coords.latitude),
   //       long: toNum(loc.coords.longitude),
   //     };
   //     setClientLocation(coords);
   //     await AsyncStorage.setItem("clientLocation", JSON.stringify(coords));
   //     const clientCoords =
   //       coords.lat != null && coords.long != null
   //         ? { lat: coords.lat, lng: coords.long }
   //         : null;
 
-  //     const res = await axios.get(`${API}/providers`);
+  //     const res = await api.get(`/providers`);
   //     const list = Array.isArray(res.data)
   //       ? res.data
   //       : res.data?.providers || [];
 
   //     const withinRadius = list
   //       .map((p) => {
   //         const providerCoords = getProviderCoords(p);
   //         const distance = clientCoords && providerCoords
   //           ? haversineKm(
   //               clientCoords.lat,
   //               clientCoords.lng,
   //               providerCoords.lat,
   //               providerCoords.lng
   //             )
   //           : null;
   //         const distance_km = Number.isFinite(distance) ? distance : null;
   //         return { ...p, distance_km };
   //       })
   //       .filter(
   //         (p) => typeof p.distance_km === "number" && p.distance_km <= 15
   //       )
   //       .sort(
   //         (a, b) => (a.distance_km ?? Infinity) - (b.distance_km ?? Infinity)
   //       );
 
@@ -3309,53 +3428,51 @@ function AppointmentsScreen({ token, showFlash }) {
   const formatBookingTime = (iso) => {
     const d = new Date(iso);
     if (Number.isNaN(d.getTime())) return "";
     let h = d.getHours();
     const m = d.getMinutes();
     const suffix = h >= 12 ? "PM" : "AM";
     h = h % 12 || 12;
     return `${h}:${m.toString().padStart(2, "0")} ${suffix}`;
   };
 
   const fetchBookings = useCallback(
     async (useRefresh = false) => {
       try {
         if (useRefresh) setRefreshing(true);
         setLoading(true);
         setError("");
 
         const authToken = await getAuthToken(token);
 
         if (!authToken) {
           setError("Please log in to view your appointments.");
           setBookings([]);
           return;
         }
 
-        const res = await axios.get(`${API}/bookings/me`, {
-          headers: { Authorization: `Bearer ${authToken}` },
-        });
+        const res = await api.get(`/bookings/me`);
 
         const raw = res.data;
         const list = Array.isArray(raw)
           ? raw
           : raw?.bookings || raw?.results || [];
 
         setBookings(list);
       } catch (err) {
         console.log(
           "Error loading appointments",
           err.response?.data || err.message
         );
         setError("Could not load your appointments.");
         if (showFlash) {
           showFlash("error", "Could not load your appointments.");
         }
       } finally {
         setLoading(false);
         if (useRefresh) setRefreshing(false);
       }
     },
     [showFlash, token?.token]
   );
 
   const handleRefresh = useCallback(() => fetchBookings(true), [fetchBookings]);
@@ -3392,56 +3509,53 @@ function AppointmentsScreen({ token, showFlash }) {
     }
   };
 
   const handleCancelBooking = (booking) => {
     const bookingId = booking?.id || booking?.booking_id;
     if (!bookingId) return;
 
     Alert.alert(
       "Cancel appointment",
       "Are you sure you want to cancel this appointment?",
       [
         { text: "No", style: "cancel" },
         {
           text: "Yes, cancel",
           style: "destructive",
           onPress: async () => {
             try {
               const authToken = await getAuthToken(token);
 
               if (!authToken) {
                 showFlash &&
                   showFlash("error", "No access token found. Please log in.");
                 return;
               }
 
-              await axios.post(
-                `${API}/bookings/${bookingId}/cancel`,
-                {},
-                {
-                  headers: { Authorization: `Bearer ${authToken}` },
-                }
+              await api.post(
+                `/bookings/${bookingId}/cancel`,
+                {}
               );
 
               setBookings((prev) =>
                 (prev || []).map((b) =>
                   b.id === bookingId || b.booking_id === bookingId
                     ? { ...b, status: "cancelled" }
                     : b
                 )
               );
 
               showFlash && showFlash("success", "Booking cancelled");
             } catch (err) {
               console.log(
                 "Error cancelling booking (appointments)",
                 err.response?.data || err.message
               );
               showFlash && showFlash("error", "Could not cancel booking.");
             }
           },
         },
       ]
     );
   };
 
   const datedBookings = bookings.map((b) => ({
@@ -3741,51 +3855,51 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
       } catch (error) {
         console.log("Error loading stored client location", error);
       }
     };
 
     loadStoredClientLocation();
 
     return () => {
       isMounted = false;
     };
   }, [clientLocation]);
 
 
   const handleSearchSubmit = () => {
     // when the user hits enter/search on the keyboard
     setHasSearched(true);
     setShouldScrollToResults(true);
   };
 
 
   const loadProviders = useCallback(async () => {
     try {
       setProvidersLoading(true);
       setProvidersError("");
 
-      const res = await axios.get(`${API}/providers`);
+      const res = await api.get(`/providers`);
 
       // Always normalize the result to an array
       const list = Array.isArray(res.data)
         ? res.data
         : res.data?.providers || [];
 
       setProviders(list);
       setFilteredProviders(list);
       syncFavoritesFromList(list);
       return list;
     } catch (err) {
       console.log(
         "Error loading providers",
         err?.response?.data || err?.message
       );
       setProvidersError("Could not load providers.");
       if (showFlash) showFlash("error", "Could not load providers.");
       return [];
     } finally {
       setProvidersLoading(false);
     }
   }, [showFlash, syncFavoritesFromList]);
 
   const clearSelectedProvider = useCallback(() => {
     setSelectedProvider(null);
@@ -4009,126 +4123,126 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
     if (shouldScrollToResults && scrollRef.current) {
       scrollRef.current.scrollTo({
         y: resultsOffset.current,
         animated: true,
       });
       setShouldScrollToResults(false);
     }
   };
 
   useEffect(() => {
     if (!shouldScrollToResults || !scrollRef.current) return;
     scrollRef.current.scrollTo({
       y: resultsOffset.current,
       animated: true,
     });
     setShouldScrollToResults(false);
   }, [shouldScrollToResults]);
 
 
   const loadAvailability = useCallback(
     async (providerId, serviceId) => {
       try {
         setAvailabilityLoading(true);
         setAvailabilityError("");
 
-        const res = await axios.get(
-          `${API}/providers/${providerId}/availability`,
+        const res = await api.get(
+          `/providers/${providerId}/availability`,
           {
             params: {
               service_id: serviceId,
               days: 14,
             },
           }
         );
 
         setAvailability(res.data || []);
       } catch (err) {
         console.log(
           "Error loading availability",
           err.response?.data || err.message
         );
         setAvailabilityError("Could not load availability for this service.");
         if (showFlash) showFlash("error", "Could not load availability.");
       } finally {
         setAvailabilityLoading(false);
       }
     },
     [showFlash]
   );
 
   const loadProviderCatalog = useCallback(async (providerId) => {
     try {
       setCatalogLoading(true);
       setCatalogError("");
 
-      const res = await axios.get(`${API}/providers/${providerId}/catalog`);
+      const res = await api.get(`/providers/${providerId}/catalog`);
 
       setCatalogImages(Array.isArray(res.data) ? res.data : []);
     } catch (err) {
       console.log(
         "Error loading provider catalog",
         err.response?.data || err.message
       );
       setCatalogError(
         err.response?.data?.detail || "Could not load provider photos."
       );
     } finally {
       setCatalogLoading(false);
     }
   }, []);
 
 
   const handleSelectProvider = useCallback(async (provider) => {
     setSelectedProvider(provider);
 
     const providerId = getProviderId(provider);
     if (!providerId) {
       setServices([]);
       setServicesError("Provider information is missing.");
       return;
     }
 
     // Reset downstream state
     setServices([]);
     setServicesError("");
     setSelectedService(null);
     setAvailability([]);
     setAvailabilityError("");
     setSelectedDate(null);
     setSelectedSlot(null);
 
     // Reset and load catalog for this provider
     setCatalogImages([]);
     setCatalogError("");
     loadProviderCatalog(providerId);
 
     try {
       setServicesLoading(true);
 
-      const res = await axios.get(
-        `${API}/providers/${providerId}/services`
+      const res = await api.get(
+        `/providers/${providerId}/services`
       );
       setServices(res.data || []);
     } catch (err) {
       console.log(
         "Error loading services",
         err.response?.data || err.message
       );
       setServicesError("Could not load services for this provider.");
       if (showFlash) showFlash("error", "Could not load provider services.");
     } finally {
       setServicesLoading(false);
     }
   }, [loadProviderCatalog, showFlash]);
 
   const handleSelectService = useCallback(
     async (service) => {
       setSelectedService(service);
       setAvailability([]);
       setAvailabilityError("");
       setSelectedDate(null);
       setSelectedSlot(null);
 
       if (!selectedProvider) return;
 
       await loadAvailability(getProviderId(selectedProvider), service.id);
@@ -4858,205 +4972,189 @@ const handleShareProfileLink = async () => {
     loadUpcomingBookings,
     loadProviderSummary,
     loadProviderProfile,
     loadProviderLocation,
     loadCatalog,
   ]);
 
 const resetForm = () => {
     setNewName("");
     setNewPrice("");
     setNewDuration("30");
     setNewDescription("");
   };
 
 const loadBookings = async () => {
     try {
       setBookingsLoading(true);
       setBookingsError("");
 
       const authToken = await getAuthToken(token);
       if (!authToken) {
         setBookingsError("No access token found. Please log in again.");
         return;
       }
 
-      const res = await axios.get(`${API}/providers/me/bookings`, {
-        headers: {
-          Authorization: `Bearer ${authToken}`,
-        },
-      });
+      const res = await api.get(`/providers/me/bookings`);
 
       setBookings(res.data || []);
     } catch (err) {
       console.log("Error loading bookings", err.response?.data || err.message);
       setBookingsError("Could not load bookings.");
       if (showFlash) {
         showFlash("error", "Could not load bookings.");
       }
     } finally {
       setBookingsLoading(false);
     }
   };
 
 const loadWorkingHours = async () => {
   try {
     setHoursLoading(true);
     setHoursError("");
 
     const authToken = await getAuthToken(token);
     if (!authToken) {
       setHoursError("No access token found. Please log in again.");
       return;
     }
 
-    const res = await axios.get(`${API}/providers/me/working-hours`, {
-      headers: { Authorization: `Bearer ${authToken}` },
-    });
+    const res = await api.get(`/providers/me/working-hours`);
 
     const rows = Array.isArray(res.data) ? res.data : [];
 
     // Map backend fields -> local editable fields
     const mapped = rows.map((row) => ({
       ...row,
       startLocal: row.start_time ? to12Hour(row.start_time) : "",
       endLocal: row.end_time ? to12Hour(row.end_time) : "",
     }));
 
      setWorkingHours(mapped);
   } catch (err) {
     console.log(
       "Error loading working hours:",
       err.response?.status,
       err.response?.data || err.message
     );
     const detail =
       err.response?.data?.detail ||
       err.response?.data?.message ||
       "Could not load working hours.";
     setHoursError(detail);
     if (showFlash) showFlash("error", detail);
   } finally {
     setHoursLoading(false);
   }
 };
 
 
 
 const loadTodayBookings = async () => {
   try {
     const authToken = await getAuthToken(token);
-    const res = await axios.get(
-      `${API}/providers/me/bookings/today`,
-      { headers: { Authorization: `Bearer ${authToken}` } }
+    const res = await api.get(
+      `/providers/me/bookings/today`
     );
     setTodayBookings(res.data || []);
   } catch (error) {
     setTodayBookingsError(true);
   }
 };
 
 useEffect(() => {
   const intervalId = setInterval(() => {
     loadTodayBookings();
   }, 60 * 1000);
 
   return () => clearInterval(intervalId);
 }, []);
 
 
 const handleCancelBooking = (bookingId) => {
   Alert.alert(
     "Cancel booking",
     "Are you sure you want to cancel this booking?",
     [
       { text: "No", style: "cancel" },
       {
         text: "Yes, cancel",
         style: "destructive",
           onPress: async () => {
           try {
             const authToken = await getAuthToken(token);
             if (!authToken) {
               if (showFlash) showFlash("error", "No access token found.");
               return;
             }
 
-            await axios.post(
-              `${API}/providers/me/bookings/${bookingId}/cancel`,
-              {},
-              {
-                headers: {
-                  Authorization: `Bearer ${authToken}`,
-                },
-              }
+            await api.post(
+              `/providers/me/bookings/${bookingId}/cancel`,
+              {}
             );
 
             if (showFlash) showFlash("success", "Booking cancelled");
 
             // ðŸ”¹ Optimistically remove from both lists so UI updates immediately
             setTodayBookings((prev) =>
               (prev || []).filter((b) => b.id !== bookingId)
             );
             setUpcomingBookings((prev) =>
               (prev || []).filter((b) => b.id !== bookingId)
             );
 
             // ðŸ”¹ (Optional) also re-sync with backend
             // await Promise.all([loadTodayBookings(), loadUpcomingBookings()]);
           } catch (err) {
             console.log(
               "Error cancelling booking",
               err.response?.data || err.message
             );
             if (showFlash) showFlash("error", "Could not cancel booking.");
           }
         },
       },
     ]
   );
 };
 
 
  
 
 const loadServices = async () => {
     try {
       setLoading(true);
       setServicesError("");
 
       const authToken = await getAuthToken(token);
       if (!authToken) {
         setServicesError("No access token found. Please log in again.");
         return;
       }
 
-      const res = await axios.get(`${API}/providers/me/services`, {
-        headers: {
-        Authorization: `Bearer ${authToken}`,
-      },
-    });
+      const res = await api.get(`/providers/me/services`);
 
         // ðŸ”’ Always normalize to an array
     const rawServices = res.data;
     const list = Array.isArray(rawServices)
       ? rawServices
       : rawServices?.services || rawServices?.results || [];
 
     setServices(list || []);
 
     } catch (err) {
       console.log("Error loading services", err.response?.data || err.message);
       setServicesError("Could not load services.");
       if (showFlash) {
         showFlash("error", "Could not load services.");
       }
     } finally {
       setLoading(false);
     }
   };
 
 const saveWorkingHours = async () => {
   try {
     const authToken = await getAuthToken(token);
     if (!authToken) {
       if (showFlash) showFlash("error", "No access token found.");
@@ -5103,53 +5201,51 @@ const saveWorkingHours = async () => {
             "Tuesday",
             "Wednesday",
             "Thursday",
             "Friday",
             "Saturday",
             "Sunday",
           ];
           const label = dayNames[h.weekday] || `Day ${h.weekday}`;
           const msg = `End time must be after start time for ${label}.`;
           if (showFlash) showFlash("error", msg);
           setHoursFlash({ type: "error", message: msg });
           setTimeout(() => setHoursFlash(null), 4000);
           return;
         }
       }
 
       payload.push({
         weekday: h.weekday,
         is_closed: h.is_closed,
         start_time: h.is_closed ? null : start24,
         end_time: h.is_closed ? null : end24,
       });
     }
 
     
-    await axios.put(`${API}/providers/me/working-hours`, payload, {
-      headers: { Authorization: `Bearer ${authToken}` },
-    });
+    await api.put(`/providers/me/working-hours`, payload);
 
 
     // if (showFlash) showFlash("success", "Working hours saved");
     setHoursFlash({ type: "success", message: "Working hours saved" });
     setTimeout(() => setHoursFlash(null), 4000);
   } catch (err) {
     console.log(
       "Error saving working hours",
       err.response?.data || err.message
     );
     if (showFlash) showFlash("error", "Could not save working hours.");
     setHoursFlash({ type: "error", message: "Could not save working hours." });
     setTimeout(() => setHoursFlash(null), 4000);
   }
 };
 
 // Convert "HH:MM" â†’ "h:MM AM/PM" (safe)
 const to12Hour = (time24) => {
   if (!time24 || typeof time24 !== "string") return "";
 
   if (!time24.includes(":")) return "";
 
   let [h, m] = time24.split(":");
 
   h = parseInt(h, 10);
@@ -5258,104 +5354,95 @@ const to24Hour = (time12) => {
           currentErrors.duration
       );
     }
     return;
   }
 
   const priceNumber = parseServiceNumber(newPrice);
   const durationNumber = parseServiceNumber(newDuration);
 
   try {
     setIsSavingService(true);
     const authToken = await getAuthToken(token);
     if (!authToken) {
       if (showFlash) showFlash("error", "No access token found.");
       return;
     }
 
     const payload = {
       name: newName.trim(),
       description: newDescription.trim(),
       duration_minutes: durationNumber,
       price_gyd: priceNumber,
     };
 
     // âœ… Create service on backend and get the created record back
-    const res = await axios.post(
-      `${API}/providers/me/services`,
-      payload,
-      {
-        headers: {
-          Authorization: `Bearer ${authToken}`,
-        },
-      }
+    const res = await api.post(
+      `/providers/me/services`,
+      payload
     );
 
     const created = res.data;
 
     // âœ… Optimistically add to local list so it shows immediately
     setServices((prev) => {
       const prevArr = Array.isArray(prev) ? prev : [];
       return [...prevArr, created];
     });
 
     if (showFlash) {
       showFlash("success", "Service created");
     }
 
     // Reset form + close add UI
     resetForm();
     setAdding(false);
 
     // Optional: background refresh to stay in sync with backend
     loadServices();
   } catch (err) {
     console.log("Error creating service", err.response?.data || err.message);
     if (showFlash) {
       const detail =
         err.response?.data?.detail || "Could not create service.";
       showFlash("error", detail);
     }
   } finally {
     setIsSavingService(false);
   }
 };
 
 
   const handleDeleteService = async (serviceId) => {
     try {
       const authToken = await getAuthToken(token);
       if (!authToken) {
         if (showFlash) showFlash("error", "No access token found.");
         return;
       }
 
-      const res = await axios.delete(`${API}/providers/me/services/${serviceId}`, {
-        headers: {
-          Authorization: `Bearer ${authToken}`,
-        },
-      });
+      const res = await api.delete(`/providers/me/services/${serviceId}`);
 
       const responseData = res?.data || {};
       const responseStatus = `${responseData.status || responseData.result || ""}`.toLowerCase();
       const responseMessage =
         responseData.detail || responseData.message || responseData.error || "";
       const responseText = `${responseStatus} ${responseMessage}`.toLowerCase();
       const hasBookings = responseText.includes("booking");
 
       if (showFlash) {
         if (hasBookings) {
           showFlash(
             "info",
             "This service has bookings and was archived instead."
           );
         } else {
           showFlash("success", "Service removed from your list.");
         }
       }
 
       await loadServices();
     } catch (err) {
       console.log("Error deleting service", err.response?.data || err.message);
       const status = err.response?.status;
       const detail =
         err.response?.data?.detail ||
@@ -5424,100 +5511,97 @@ const loadProviderProfile = async () => {
         username: res.data.username || "",
       });
 
       setAvatarUrl(res.data.avatar_url || null);
 
   } catch (err) {
     console.log("Error loading provider profile", err.response?.data || err.message);
     setProfileError("Could not load provider profile.");
     if (showFlash) showFlash("error", "Could not load provider profile.");
   } finally {
     setProfileLoading(false);
   }
 };
 
 const loadCatalog = async () => {
   try {
     setCatalogLoading(true);
     setCatalogError("");
 
     const authToken = await getAuthToken(token);
     if (!authToken) {
       setCatalogError("No access token found. Please log in again.");
       return;
     }
 
-    const res = await axios.get(`${API}/providers/me/catalog`, {
-      headers: { Authorization: `Bearer ${authToken}` },
-    });
+    const res = await api.get(`/providers/me/catalog`);
 
     setCatalog(Array.isArray(res.data) ? res.data : []);
   } catch (err) {
     console.log(
       "Error loading provider catalog",
       err.response?.data || err.message
     );
     const detail =
       err.response?.data?.detail ||
       "Could not load your catalog images.";
     setCatalogError(detail);
     if (showFlash) showFlash("error", detail);
   } finally {
     setCatalogLoading(false);
   }
 };
 
 
 const uploadCatalogImage = async (uri) => {
   try {
     setCatalogUploading(true);
 
     const authToken = await getAuthToken(token);
     if (!authToken) {
       alert("No access token found. Please log in again.");
       return;
     }
 
     const filename = uri.split("/").pop() || "catalog.jpg";
     const match = /\.(\w+)$/.exec(filename);
     const ext = match ? match[1].toLowerCase() : "jpg";
 
     let mimeType = "image/jpeg";
     if (ext === "png") mimeType = "image/png";
     else if (ext === "webp") mimeType = "image/webp";
 
     const formData = new FormData();
     formData.append("file", {
       uri,
       name: filename,
       type: mimeType,
     });
 
-    const res = await axios.post(`${API}/providers/me/catalog`, formData, {
+    const res = await api.post(`/providers/me/catalog`, formData, {
       headers: {
         "Content-Type": "multipart/form-data",
-        Authorization: `Bearer ${authToken}`,
       },
     });
 
     const created = res.data;
     setCatalog((prev) => [created, ...(prev || [])]);
 
     if (showFlash) showFlash("success", "Photo added to your catalog");
   } catch (err) {
     console.log(
       "Error uploading catalog image",
       err.response?.data || err.message
     );
     const detail =
       err.response?.data?.detail ||
       "Could not upload image. Please try again.";
     if (showFlash) showFlash("error", detail);
   } finally {
     setCatalogUploading(false);
   }
 };
 
 
 const pickCatalogImage = async () => {
   try {
     const result = await ImagePicker.launchImageLibraryAsync({
@@ -5539,104 +5623,97 @@ const pickCatalogImage = async () => {
     await uploadCatalogImage(asset.uri);
   } catch (err) {
     console.log("Error picking catalog image", err);
     alert("Could not open your gallery. Please try again.");
   }
 };
 
 
 const handleDeleteCatalogImage = (imageId) => {
   Alert.alert(
     "Remove photo",
     "Do you want to remove this photo from your catalog?",
     [
       { text: "Cancel", style: "cancel" },
       {
         text: "Remove",
         style: "destructive",
         onPress: async () => {
           try {
             const authToken = await getAuthToken(token);
             if (!authToken) {
               alert("No access token found. Please log in again.");
               return;
             }
 
-            await axios.delete(`${API}/providers/me/catalog/${imageId}`, {
-              headers: { Authorization: `Bearer ${authToken}` },
-            });
+            await api.delete(`/providers/me/catalog/${imageId}`);
 
             setCatalog((prev) =>
               (prev || []).filter((img) => img.id !== imageId)
             );
 
             if (showFlash) {
               showFlash("success", "Photo removed from your catalog");
             }
           } catch (err) {
             console.log(
               "Error deleting catalog image",
               err.response?.data || err.message
             );
             const detail =
               err.response?.data?.detail ||
               "Could not remove photo. Please try again.";
             if (showFlash) showFlash("error", detail);
           }
         },
       },
     ]
   );
 };
 
 
 const saveProviderProfile = async () => {
   try {
     const authToken = await getAuthToken(token);
     if (!authToken) {
       if (showFlash) showFlash("error", "No access token found.");
       return;
     }
 
     const payload = {
       full_name: profile.full_name,
       phone: profile.phone,
       whatsapp: profile.whatsapp,
       location: profile.location,
       bio: profile.bio,
       professions: profile.professions || [],
     };
 
     // âœ… Save provider profile to backend
-    const res = await axios.put(
-      `${API}/providers/me/profile`,
-      payload,
-      {
-        headers: {
-          Authorization: `Bearer ${authToken}`,
-        },
-      }
+    const res = await api.put(
+      `/providers/me/profile`,
+      payload
     );
 
     // âœ… Update local state from server response so UI reflects whatâ€™s saved
     setProfile({
       full_name: res.data.full_name || "",
       phone: res.data.phone || "",
       whatsapp: res.data.whatsapp || "",
       location: res.data.location || "",
       bio: res.data.bio || "",
       professions: res.data.professions || [],
       username: res.data.username || "",
     });
 
     // âœ… Show success flash in the green bar
     setHoursFlash({ type: "success", message: "Provider profile saved" });
     setTimeout(() => setHoursFlash(null), 4000);
   } catch (err) {
     console.log("Error saving provider profile", err.response?.data || err.message);
 
     setHoursFlash({ type: "error", message: "Provider profile not saved" });
     setTimeout(() => setHoursFlash(null), 4000);
 
     if (showFlash) {
       const detail =
         err.response?.data?.detail || "Could not save provider profile.";
@@ -5707,156 +5784,149 @@ const uploadAvatar = async (uri) => {
     const res = await apiClient.post(endpoint, formData, {
       headers: {
         "Content-Type": "multipart/form-data",
       },
     });
 
     const newUrl = res.data.avatar_url;
 
     // update avatar in this screen
     setAvatarUrl(newUrl);
 
     // if this screen has a provider object, keep it in sync (no-op for pure clients)
     if (typeof setProvider === "function") {
       setProvider((prev) => (prev ? { ...prev, avatar_url: newUrl } : prev));
     }
   } catch (err) {
     console.log("Avatar upload error:", err.response?.data || err.message);
     alert("Failed to upload avatar. Please try again.");
   }
 };
 
 
 const loadUpcomingBookings = async () => {
   try {
     const authToken = await getAuthToken(token);
-    const res = await axios.get(
-      `${API}/providers/me/bookings/upcoming`,
-      { headers: { Authorization: `Bearer ${authToken}` } }
+    const res = await api.get(
+      `/providers/me/bookings/upcoming`
     );
     setUpcomingBookings(res.data || []);
   } catch (error) {
     setUpcomingBookingsError(true);
   }
 };
 
 
 
 const getCurrentLocation = async () => {
   let { status } = await Location.requestForegroundPermissionsAsync();
   if (status !== "granted") {
     return null;
   }
 
   const loc = await Location.getCurrentPositionAsync({});
   return {
     lat: loc.coords.latitude,
     long: loc.coords.longitude
   };
 };
 
 
 const handlePinLocation = async () => {
   try {
     const authToken = await getAuthToken(token);
     if (!authToken) {
       if (showFlash) showFlash("error", "No access token found. Please log in again.");
       return;
     }
 
     const coords = await getCurrentLocation();
     if (!coords) {
       Alert.alert(
         "Permission needed",
         "Location permission is required to pin your business on the map."
       );
       if (showFlash) showFlash("error", "Location permission denied.");
       return;
     }
 
     // 1) update the user record
-    await axios.put(
-      `${API}/users/me`,
-      { lat: coords.lat, long: coords.long },
-      { headers: { Authorization: `Bearer ${authToken}` } }
+    await api.put(
+      `/users/me`,
+      { lat: coords.lat, long: coords.long }
     );
 
     // 2) ALSO update the provider record so searches & client view use it
-    await axios.put(
-      `${API}/providers/me/location`,
-      { lat: coords.lat, long: coords.long },
-      { headers: { Authorization: `Bearer ${authToken}` } }
+    await api.put(
+      `/providers/me/location`,
+      { lat: coords.lat, long: coords.long }
     );
 
     // 3) update local state so preview uses the latest coords
     setProviderLocation(coords);
 
     if (showFlash) showFlash("success", "Business location pinned here.");
     Alert.alert(
       "Location pinned",
       "Clients will now navigate to this location."
     );
   } catch (err) {
     console.log("Error pinning location", err.response?.data || err.message);
     if (showFlash) {
       const msg =
         err.response?.data?.detail ||
         err.response?.data?.message ||
         "Could not pin business location.";
       showFlash("error", msg);
     }
   }
 };
 
 const loadProviderLocation = async () => {
   try {
     const storedToken = await loadToken();
     if (!storedToken) return;
 
      const res = await apiClient.get("/users/me");
 
     if (res.data.lat != null && res.data.long != null) {
       setProviderLocation({
         lat: res.data.lat,
         long: res.data.long,
       });
     }
   } catch (err) {
     console.log("Error loading provider location", err.response?.data || err.message);
   }
 };
 
 const loadProviderSummary = async () => {
   try {
     const authToken = await getAuthToken(token);
     if (!authToken) return;
 
-    const res = await axios.get(`${API}/providers/me/summary`, {
-      headers: {
-        Authorization: `Bearer ${authToken}`,
-      },
-    });
+    const res = await api.get(`/providers/me/summary`);
     setProviderSummary(res.data);
   } catch (err) {
     console.log(
       "Error loading provider summary",
       err.response?.data || err.message
     );
   }
 };
 
   const insets = useSafeAreaInsets();
   // const headerMinHeight =
   //   insets.top + HEADER_LOGO_HEIGHT + HEADER_VERTICAL_PADDING * 2;
   const headerPaddingVertical = HEADER_VERTICAL_PADDING;
 
   return (
     <View style={styles.homeWrapper}>
       {hoursFlash && (
         <View
           style={[
             styles.hoursFlashGlobal,
             hoursFlash.type === "error"
               ? styles.hoursFlashError
               : styles.hoursFlashSuccess,
           ]}
         >
@@ -6708,55 +6778,53 @@ function ProviderBillingScreen({ token, showFlash }) {
     return dateObj;
   };
 
   const formatDate = (value) => {
     const dateObj = parseDateOnly(value);
     if (!dateObj) return "-";
     return dateObj.toLocaleDateString("en-US", {
       month: "short",
       day: "numeric",
       year: "numeric",
     });
   };
 
   const fetchBilling = useCallback(async () => {
     try {
       setBillingLoading(true);
       setBillingError("");
 
       const authToken = await getAuthToken(token);
 
       if (!authToken) {
         setBillingError("No access token found. Please log in again.");
         return;
       }
 
-      const billingEndpoint = `${API}/providers/me/billing/cycles?limit=6`;
+      const billingEndpoint = `/providers/me/billing/cycles?limit=6`;
 
-      const response = await axios.get(billingEndpoint, {
-        headers: { Authorization: `Bearer ${authToken}` },
-      });
+      const response = await api.get(billingEndpoint);
 
       const summaryData = response?.data || null;
       setBillingSummary(summaryData);
 
       const cycles = Array.isArray(summaryData?.cycles)
         ? summaryData.cycles
         : [];
       setBillingCycles(cycles);
     } catch (err) {
       console.log("Error loading billing", err.response?.data || err.message);
       setBillingError("Could not load billing statements.");
       if (showFlash) {
         showFlash("error", "Could not load billing statements.");
       }
     } finally {
       setBillingLoading(false);
     }
   }, [showFlash, token?.token]);
 
   useEffect(() => {
     fetchBilling();
   }, [fetchBilling]);
 
   useFocusEffect(
     useCallback(() => {
@@ -7361,96 +7429,88 @@ function ProviderCalendarScreen({ token, showFlash }) {
     (booking) => {
       const status = getBookingStatusLabel(booking);
       if (status.type === "cancelled" || status.type === "completed") return false;
 
       const normalizedStatus = String(booking?.status || booking?.state || "")
         .trim()
         .toLowerCase();
 
       return normalizedStatus === "confirmed";
     },
     [getBookingStatusLabel]
   );
 
   const loadBookingsForRange = useCallback(async (useRefresh = false) => {
     try {
       if (useRefresh) setRefreshing(true);
       setLoading(true);
       setError("");
 
       const authToken = await getAuthToken(token);
       if (!authToken) {
         setError("No access token found. Please log in again.");
         return;
       }
 
-      const res = await axios.get(`${API}/providers/me/bookings`, {
-        headers: {
-          Authorization: `Bearer ${authToken}`,
-        },
+      const res = await api.get(`/providers/me/bookings`, {
         params: {
           start: dateRange.start,
           end: dateRange.end,
         },
       });
 
       const rows = Array.isArray(res.data)
         ? res.data
         : res.data?.bookings || res.data?.results || [];
 
       setBookings(dedupeById(rows));
     } catch (err) {
       console.log("Error loading provider calendar bookings", err?.response?.data || err?.message || err);
       setError("Could not load calendar bookings.");
       if (showFlash) {
         showFlash("error", "Could not load calendar bookings.");
       }
     } finally {
       setLoading(false);
       if (useRefresh) setRefreshing(false);
     }
   }, [dateRange.end, dateRange.start, formatDayKey, showFlash, token]);
 
   const handleRefresh = useCallback(() => loadBookingsForRange(true), [loadBookingsForRange]);
 
   const cancelBookingById = useCallback(
     async (bookingId, authTokenOverride) => {
       const authToken = authTokenOverride || (await getAuthToken(token));
       if (!authToken) {
         const noAuthError = new Error("No access token found. Please log in again.");
         noAuthError.code = "NO_AUTH_TOKEN";
         throw noAuthError;
       }
 
-      await axios.post(
-        `${API}/providers/me/bookings/${bookingId}/cancel`,
-        {},
-        {
-          headers: {
-            Authorization: `Bearer ${authToken}`,
-          },
-        }
+      await api.post(
+        `/providers/me/bookings/${bookingId}/cancel`,
+        {}
       );
 
     },
     [token]
   );
 
   const handleCancelAppointment = useCallback(
     (booking) => {
       if (cancelAllLoading) return;
       const bookingId = getBookingId(booking);
       if (!bookingId || cancellingByBookingId[bookingId]) return;
 
       Alert.alert(
         "Cancel appointment?",
         "This will notify the customer.",
         [
           { text: "Keep", style: "cancel" },
           {
             text: "Cancel appointment",
             style: "destructive",
             onPress: async () => {
               if (cancellingByBookingId[bookingId]) return;
 
               setCancellingByBookingId((prev) => ({ ...prev, [bookingId]: true }));
               try {
@@ -8345,142 +8405,146 @@ function FlashMessage({ flash }) {
 
 const DEEPLINK_DEBUG = false;
 
 function App() {
 
   const mountIdRef = useRef(Math.random().toString(16).slice(2));
   console.log("APP MOUNT ID:", mountIdRef.current);
   useEffect(() => console.log("APP useEffect ran for mount", mountIdRef.current), []);
 
   const [token, setToken] = useState(null);
   const [authLoading, setAuthLoading] = useState(true);
   const [authMode, setAuthMode] = useState("landing"); // 'landing' | 'login' | 'signup' | 'forgot' | 'finishSetup'
   const [isAdmin, setIsAdmin] = useState(false);
   const [facebookSetup, setFacebookSetup] = useState(null);
   const [pendingDeepLinkUsername, setPendingDeepLinkUsername] = useState(null);
   const [navReady, setNavReady] = useState(false);
   const navReadyRef = useRef(false);
   const navigationRef = useRef(null);
   const authBootstrapRef = useRef({ inFlight: false, completed: false });
   const tokenRef = useRef(token);
   const lastDeeplinkHandledAtRef = useRef(0);
   const lastHandledUrlRef = useRef(null);
   const url = ExpoLinking.useURL();
 
   const [flash, setFlash] = useState(null);
+  const apiClient = api;
 
   const handleUnauthorized = useCallback(async () => {
+     setApiAccessToken(null);
      try {
        await clearAllAuthTokens(); // âœ… clears access + refresh (and your new fallbacks)
      } catch (storageError) {
        console.log(
          "[auth] Failed to clear all auth tokens",
          storageError?.message || storageError
        );
      }
 
      try {
        await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY); // optional, but fine
      } catch (storageError) {
        console.log(
          "[auth] Failed to clear legacy token",
          storageError?.message || storageError
        );
      }
 
      setToken(null);
     }, []);
 
 
   // const handleUnauthorized = useCallback(async () => {
   //   try {
   //     await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
   //   } catch (storageError) {
   //     console.log(
   //       "[auth] Failed to clear legacy token",
   //       storageError?.message || storageError
   //     );
   //   }
   //   setToken(null);
   // }, []);
 
-  const apiClient = useMemo(
-    () =>
-      createApiClient({
-        baseURL: API,
-        onUnauthorized: handleUnauthorized,
-      }),
-    [handleUnauthorized]
-  );
+  useEffect(() => {
+    setApiUnauthorizedHandler(handleUnauthorized);
+    return () => {
+      setApiUnauthorizedHandler(null);
+    };
+  }, [handleUnauthorized]);
 
 
 
   const formatFlashText = useCallback((text) => {
     if (typeof text === "string") return text;
     if (text == null) return "Something went wrong.";
 
     const formatErrorItem = (item) => {
       if (typeof item === "string") return item;
       if (!item || typeof item !== "object") return String(item);
 
       const message = item.msg || item.message;
       if (Array.isArray(item.loc) && item.loc.length > 0) {
         const field = item.loc[item.loc.length - 1];
         return message ? `${field}: ${message}` : String(item);
       }
       if (message) return message;
       return JSON.stringify(item);
     };
 
     if (Array.isArray(text)) {
       return text.map(formatErrorItem).filter(Boolean).join("\n");
     }
 
     if (typeof text === "object") {
       if (Array.isArray(text.detail)) {
         return formatFlashText(text.detail);
       }
       if (typeof text.detail === "string") return text.detail;
       if (typeof text.message === "string") return text.message;
       if (typeof text.msg === "string") return text.msg;
       return JSON.stringify(text);
     }
 
     return String(text);
   }, []);
 
   const showFlash = useCallback((type, text) => {
     setFlash({ type, text: formatFlashText(text) });
     setTimeout(() => {
       setFlash(null);
     }, 4500);
   }, [formatFlashText]);
 
   useEffect(() => {
     tokenRef.current = token;
   }, [token]);
 
+  useEffect(() => {
+    setApiAccessToken(token?.token || null);
+  }, [token?.token]);
+
   useEffect(() => {
     navReadyRef.current = navReady;
   }, [navReady]);
 
   useEffect(() => {
     if (!token) setNavReady(false);
   }, [token]);
 
   const navigateToClientSearch = useCallback(
   (username, navRef, nonce) => {
     if (!navRef?.current) return false;
 
     const params = { incomingUsername: username, deeplinkNonce: nonce };
 
     navRef.current.navigate({
       name: "Search",
       params,
       merge: false,
     });
 
     return true;
   },
   []
 );
 
@@ -8581,65 +8645,64 @@ function App() {
       ok
     );
     if (ok) setPendingDeepLinkUsername(null);
   }, [pendingDeepLinkUsername, token, navReady, showFlash]);
 
   useEffect(() => {
     let isActive = true;
     const restoreSession = async () => {
       if (authBootstrapRef.current.inFlight || authBootstrapRef.current.completed) {
         return;
       }
       authBootstrapRef.current.inFlight = true;
       const bootstrapStartedAt = Date.now();
       console.log("[auth] bootstrap start");
       try {
         const restoredToken = await withTimeout(
           getAuthToken(),
           AUTH_TOKEN_TIMEOUT_MS,
           "getAuthToken"
         );
         console.log("[auth] token loaded:", Boolean(restoredToken));
 
         if (!restoredToken) {
           if (isActive) setToken(null);
         } else {
+          setApiAccessToken(restoredToken);
           try {
             const meRes = await withTimeout(
               apiClient.get("/users/me", {
-                headers: {
-                  Authorization: `Bearer ${restoredToken}`,
-                },
                 timeout: AUTH_ME_TIMEOUT_MS,
               }),
               AUTH_ME_TIMEOUT_MS,
               "/users/me"
             );
             console.log("[auth] /users/me success", meRes?.status);
+            const latestToken = await getAuthToken();
             if (isActive) {
               setToken({
-                token: restoredToken,
+                token: latestToken || restoredToken,
                 userId: meRes.data?.id || meRes.data?.user_id,
                 email: meRes.data?.email,
                 username: meRes.data?.username,
                 isProvider: Boolean(meRes.data?.is_provider),
                 isAdmin: Boolean(meRes.data?.is_admin),
               });
               setIsAdmin(Boolean(meRes.data?.is_admin));
             }
           } catch (err) {
             console.log(
               "[auth] Failed to load user info during bootstrap",
               err?.message || err
             );
             console.log(
               "[auth] /users/me failed",
               err?.response?.status || err?.code || "unknown"
             );
             if (err?.response?.status === 401 || err?.response?.status === 403) {
               try {
                 await withTimeout(clearAllAuthTokens(), 2500, "clearAllAuthTokens");
               } catch (storageError) {
                 console.log(
                   "[auth] Failed to clear all auth tokens",
                   storageError?.message || storageError
                 );
 
EOF
)