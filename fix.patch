 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index a50580c6cc748d28466583e34c149264bb00a6e7..a0205b8e966624f606b5eb15f97890c4c832df89 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -6632,120 +6632,146 @@ function DayScheduleGrid({ events, startHour, endHour }) {
                   <Text style={styles.providerDayScheduleEventSummary} numberOfLines={1} ellipsizeMode="tail">
                     {event?.summary || "Customer"}
                   </Text>
                 </View>
                 {completed ? (
                   <View style={styles.providerDayScheduleCompletedBadge}>
                     <Text style={styles.providerDayScheduleCompletedText}>Completed</Text>
                   </View>
                 ) : null}
               </TouchableOpacity>
             );
           })}
         </View>
       </View>
     </ScrollView>
   );
 }
 
 
 
 
 function ProviderCalendarScreen({ token, showFlash }) {
   // Keep the calendar in fixed-height view wrappers so it cannot expand into the appointments header/list area.
   const WEEKLY_FIRST_DAY = 1;
   const PROVIDER_CALENDAR_DEBUG = false;
-  const toLocalDateString = useCallback((dateLike) => {
+  const parseLocalMidday = useCallback((dateKey) => {
+    if (typeof dateKey !== "string") return null;
+    const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateKey);
+    if (!match) return null;
+    const [, yyyyStr, mmStr, ddStr] = match;
+    const yyyy = Number(yyyyStr);
+    const mm = Number(mmStr);
+    const dd = Number(ddStr);
+    if (!Number.isInteger(yyyy) || !Number.isInteger(mm) || !Number.isInteger(dd)) return null;
+    const parsed = new Date(yyyy, mm - 1, dd, 12, 0, 0);
+    if (Number.isNaN(parsed.getTime())) return null;
+    return parsed;
+  }, []);
+  const normalizeDateKey = useCallback((dateLike) => {
     if (!dateLike) return null;
-    const parsed = dateLike instanceof Date ? dateLike : new Date(dateLike);
+    let parsed = null;
+    if (dateLike instanceof Date) {
+      parsed = dateLike;
+    } else if (typeof dateLike === "string") {
+      if (/^\d{4}-\d{2}-\d{2}$/.test(dateLike)) {
+        parsed = parseLocalMidday(dateLike);
+      } else if (dateLike.includes("T")) {
+        parsed = new Date(dateLike);
+      } else {
+        return null;
+      }
+    } else {
+      return null;
+    }
     if (Number.isNaN(parsed.getTime())) return null;
     const yyyy = parsed.getFullYear();
     const mm = String(parsed.getMonth() + 1).padStart(2, "0");
     const dd = String(parsed.getDate()).padStart(2, "0");
     return `${yyyy}-${mm}-${dd}`;
-  }, []);
+  }, [parseLocalMidday]);
   const [viewMode, setViewMode] = useState("month");
-  const [selectedDate, setSelectedDate] = useState(() => toLocalDateString(new Date()) || "");
+  const [selectedDate, setSelectedDate] = useState(() => normalizeDateKey(new Date()) || "");
   const [bookingsByDate, setBookingsByDate] = useState({});
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState("");
 
   const dateRange = useMemo(() => {
     const base = new Date(`${selectedDate}T12:00:00`);
     const monthStart = new Date(base.getFullYear(), base.getMonth(), 1);
     const monthEnd = new Date(base.getFullYear(), base.getMonth() + 1, 0);
     return {
-      start: toLocalDateString(monthStart),
-      end: toLocalDateString(monthEnd),
+      start: normalizeDateKey(monthStart),
+      end: normalizeDateKey(monthEnd),
     };
-  }, [selectedDate, toLocalDateString]);
+  }, [normalizeDateKey, selectedDate]);
 
-  const formatDayKey = useCallback((iso) => toLocalDateString(iso), [toLocalDateString]);
+  const formatDayKey = useCallback((bookingStartTime) => normalizeDateKey(bookingStartTime), [normalizeDateKey]);
 
   const isBookingCompleted = useCallback((booking) => {
     const now = Date.now();
     const endTime = booking?.end_time || booking?.end;
     if (endTime) {
       const endMs = new Date(endTime).getTime();
       return Number.isFinite(endMs) && endMs < now;
     }
 
     const startTime = booking?.start_time || booking?.start;
     const durationMin = Number(booking?.duration_minutes || booking?.duration || 0);
     if (!startTime) return false;
     const startMs = new Date(startTime).getTime();
     if (!Number.isFinite(startMs)) return false;
     return startMs + Math.max(durationMin, 0) * 60_000 < now;
   }, []);
 
   const loadBookingsForRange = useCallback(async () => {
     try {
       setLoading(true);
       setError("");
 
       const authToken = await getAuthToken(token);
       if (!authToken) {
         setError("No access token found. Please log in again.");
         return;
       }
 
       const res = await axios.get(`${API}/providers/me/bookings`, {
         headers: {
           Authorization: `Bearer ${authToken}`,
         },
         params: {
           start: dateRange.start,
           end: dateRange.end,
         },
       });
 
       const rows = Array.isArray(res.data)
         ? res.data
         : res.data?.bookings || res.data?.results || [];
 
       const grouped = rows.reduce((acc, booking) => {
-        const key = formatDayKey(booking?.start_time || booking?.start);
+        const key = formatDayKey(booking?.start_time);
         if (!key) return acc;
         if (!acc[key]) acc[key] = [];
         acc[key].push(booking);
         return acc;
       }, {});
 
       setBookingsByDate(grouped);
     } catch (err) {
       console.log("Error loading provider calendar bookings", err?.response?.data || err?.message || err);
       setError("Could not load calendar bookings.");
       if (showFlash) {
         showFlash("error", "Could not load calendar bookings.");
       }
     } finally {
       setLoading(false);
     }
   }, [dateRange.end, dateRange.start, formatDayKey, showFlash, token]);
 
   useEffect(() => {
     loadBookingsForRange();
   }, [loadBookingsForRange]);
 
   const selectedBookings = useMemo(() => bookingsByDate[selectedDate] || [], [bookingsByDate, selectedDate]);
 
   const formatTimelineTime = useCallback((isoDateLike) => {
@@ -6823,68 +6849,69 @@ function ProviderCalendarScreen({ token, showFlash }) {
   const calendarTheme = useMemo(
     () => ({
       backgroundColor: colors.surface,
       calendarBackground: colors.surface,
       dayTextColor: colors.textPrimary,
       monthTextColor: colors.textPrimary,
       textSectionTitleColor: colors.textSecondary,
       selectedDayBackgroundColor: colors.primarySoft,
       selectedDayTextColor: colors.textPrimary,
       todayTextColor: colors.primary,
       arrowColor: colors.primary,
       textDisabledColor: colors.textMuted,
       dotColor: colors.primary,
       selectedDotColor: colors.textPrimary,
       timelineContainerBackground: colors.surface,
       timelineBackgroundColor: colors.surface,
       timelineLineColor: colors.border,
       timelineTextColor: colors.textPrimary,
       timelineNowIndicatorColor: colors.primary,
     }),
     []
   );
 
   const onSelectDate = useCallback((value) => {
     if (!value) return;
-    const nextDate = typeof value === "string" ? value : value.dateString;
+    const raw = typeof value === "string" ? value : value.dateString;
+    const nextDate = normalizeDateKey(raw);
     if (!nextDate) return;
     setSelectedDate(nextDate);
-  }, []);
+  }, [normalizeDateKey]);
 
   useEffect(() => {
     if (!PROVIDER_CALENDAR_DEBUG) return;
-    const selected = new Date(`${selectedDate}T12:00:00`);
-    if (Number.isNaN(selected.getTime())) {
+    const selected = parseLocalMidday(selectedDate);
+    if (!selected) {
       console.log("[ProviderCalendarScreen][WeeklyDebug] invalid selectedDate", { selectedDate });
       return;
     }
     console.log("[ProviderCalendarScreen][WeeklyDebug]", {
       selectedDate,
-      weekStartDayIndex: selected.getDay(),
+      selectedWeekday: selected.getDay(),
       firstDay: WEEKLY_FIRST_DAY,
     });
-  }, [PROVIDER_CALENDAR_DEBUG, WEEKLY_FIRST_DAY, selectedDate]);
+  }, [PROVIDER_CALENDAR_DEBUG, WEEKLY_FIRST_DAY, parseLocalMidday, selectedDate]);
 
   const dayGridEvents = useMemo(
     () =>
       timelineEvents
         .map((event) => {
           const startDate = new Date(event.start);
           const endDate = new Date(event.end);
           if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
           return {
             ...event,
             startDate,
             endDate,
           };
         })
         .filter(Boolean),
     [timelineEvents]
   );
 
   return (
     <SafeAreaView style={styles.providerCalendarScreen} edges={["left", "right", "bottom"]}>
       <View style={styles.providerCalendarContentContainer}>
         <View style={styles.providerCalendarModeSwitch}>
           {[
             { key: "day", label: "Daily" },
             { key: "week", label: "Weekly" },
 
EOF
)