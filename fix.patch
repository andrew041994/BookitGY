 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index e60cbb0491776c957c65dd708de6c7aa7b36bda9..955d5c91d7c2c74ea0f8cffb2a9aa568853eee92 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -2380,122 +2380,139 @@ function SearchScreen({
       setProvidersError("Could not load providers.");
       if (showFlash) showFlash("error", "Could not load providers.");
       return [];
     } finally {
       setProvidersLoading(false);
     }
   }, [showFlash, syncFavoritesFromList]);
 
   // Load providers on mount
   useEffect(() => {
     loadProviders();
   }, [loadProviders]);
 
   useEffect(() => {
     const providerFromNav = route?.params?.provider;
     if (!providerFromNav) return;
 
     const incomingId = getProviderId(providerFromNav);
     const currentId = getProviderId(selectedProvider);
     if (incomingId && incomingId === currentId) return;
 
     setSearchQuery(providerFromNav.name || "");
     setHasSearched(true);
     setFilteredProviders([providerFromNav]);
     handleSelectProvider(providerFromNav);
-  }, [route?.params?.provider, selectedProvider]);
+  }, [route?.params?.provider, selectedProvider, handleSelectProvider]);
 
-
-
-//Add a useEffect that recomputes filteredProviders 
-// whenever providers/search/radius/location changes:
+  // Add a useEffect that recomputes filteredProviders
+  // whenever providers/search/radius/location changes:
   useEffect(() => {
     // ðŸ‘‡ do nothing until the user actually searches or if the query is empty
     const trimmedQuery = searchQuery.trim();
     if (!hasSearched || !trimmedQuery) {
       setFilteredProviders([]);
       return;
     }
 
     const q = trimmedQuery.toLowerCase();
 
     const providerList = Array.isArray(providers) ? providers : [];
-      let list = providerList.map((p) => {
-            let distance_km = null;
-          if (clientLocation && p.lat != null && p.long != null) {
-            distance_km = haversineKm(
-              clientLocation.lat,
-              clientLocation.long,
-              p.lat,
-              p.long
-            );
-          }
-          return { ...p, distance_km };
-        });
+    const providerFromNav = route?.params?.provider;
+    const navProviderId = getProviderId(providerFromNav);
+    const navProviderName = (providerFromNav?.name || "").trim().toLowerCase();
+
+    // If we navigated in with a specific provider, keep the results scoped
+    // to that provider ID so namesakes don't appear.
+    if (
+      navProviderId &&
+      navProviderName &&
+      trimmedQuery.toLowerCase() === navProviderName
+    ) {
+      const exactMatch = providerList.find(
+        (p) => getProviderId(p) === navProviderId
+      );
+
+      setFilteredProviders([exactMatch || providerFromNav]);
+      return;
+    }
+
+    let list = providerList.map((p) => {
+      let distance_km = null;
+      if (clientLocation && p.lat != null && p.long != null) {
+        distance_km = haversineKm(
+          clientLocation.lat,
+          clientLocation.long,
+          p.lat,
+          p.long
+        );
+      }
+      return { ...p, distance_km };
+    });
 
     // text filter (profession/name/location)
     if (q) {
       list = list.filter((p) => {
         const name = (p.name || "").toLowerCase();
         const location = (p.location || "").toLowerCase();
         const professions = (p.professions || []).map((pr) =>
           (pr || "").toLowerCase()
         );
 
         return (
           professions.some((pr) => pr.includes(q)) ||
           name.includes(q) ||
           location.includes(q)
         );
       });
     }
 
     // distance filter
     if (radiusKm > 0) {
       if (!clientLocation) {
         setLocationError(
           "Turn on location services to filter providers by distance."
         );
       } else {
         setLocationError("");
         list = list.filter(
           (p) =>
             typeof p.distance_km === "number" &&
             p.distance_km <= radiusKm
         );
         list.sort((a, b) => {
           const da = a.distance_km ?? 999999;
           const db = b.distance_km ?? 999999;
           return da - db;
         });
       }
     } else {
       setLocationError("");
     }
 
     setFilteredProviders(list);
-  }, [providers, searchQuery, radiusKm, clientLocation, hasSearched]);
+  }, [providers, searchQuery, radiusKm, clientLocation, hasSearched, route?.params?.provider]);
 
 
 
   const ensureClientLocation = async () => {
     try {
       const { status } = await Location.requestForegroundPermissionsAsync();
       if (status !== "granted") {
         setLocationError(
           "Location permission is required to filter by distance."
         );
         if (showFlash) {
           showFlash(
             "error",
             "Please enable location permission to use distance filters."
           );
         }
         return null;
       }
 
       const loc = await Location.getCurrentPositionAsync({});
       const coords = {
         lat: loc.coords.latitude,
         long: loc.coords.longitude,
       };
       setClientLocation(coords);
@@ -5618,53 +5635,56 @@ const styles = StyleSheet.create({
   carouselList: {
     paddingVertical: 4,
     paddingRight: 12,
   },
 
   providerCard: {
     width: 280,
     borderRadius: 12,
     backgroundColor: "#ffffff",
     marginRight: 12,
     overflow: "hidden",
     borderWidth: 1,
     borderColor: "#e5e7eb",
   },
   cardImageWrapper: {
     height: 140,
     backgroundColor: "#dcfce7",
     position: "relative",
   },
 
 cardHeartButton: {
     position: "absolute",
     top: 10,
     right: 10,
     zIndex: 12,
+    width: 36,
+    height: 36,
     backgroundColor: "rgba(255,255,255,0.9)",
-    borderRadius: 16,
-    padding: 6,
+    borderRadius: 999,
+    alignItems: "center",
+    justifyContent: "center",
   },
 
   cardImage: {
     width: "100%",
     height: "100%",
   },
   cardImageFallback: {
     flex: 1,
     alignItems: "center",
     justifyContent: "center",
     backgroundColor: "#16a34a",
   },
   cardBadge: {
     position: "absolute",
     bottom: 8,
     left: 8,
     backgroundColor: "#ecfdf3",
     borderColor: "#bbf7d0",
     borderWidth: 1,
     borderRadius: 999,
     paddingHorizontal: 10,
     paddingVertical: 4,
   },
   cardBadgeText: {
     color: "#166534",
 
EOF
)