 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index a1ded92da853104ec6fcf86696794268e8380246..47db761ec52357f77b8d74f0f1de3cdd686010c5 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -1,26 +1,26 @@
-import React, { useState, useEffect, useCallback } from "react";
+import React, { useState, useEffect, useCallback, useRef } from "react";
 import { useFocusEffect } from "@react-navigation/native";
 import { Text, View, StyleSheet, TextInput, Button, Alert, ActivityIndicator, ScrollView,
          TouchableOpacity, Switch, Linking, Platform, Image,  KeyboardAvoidingView,
          TouchableWithoutFeedback, Keyboard, RefreshControl,} from "react-native";
 import {
   NavigationContainer,
   getStateFromPath as defaultGetStateFromPath,
 } from "@react-navigation/native";
 import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
 import axios from "axios";
 import AsyncStorage from "@react-native-async-storage/async-storage";
 import * as Location from "expo-location";
 import * as Notifications from "expo-notifications";
 import Constants from "expo-constants";
 import * as ImagePicker from "expo-image-picker";
 import * as Clipboard from "expo-clipboard";
 import BookitGYLogo from "./assets/bookitgy-logo.png";
 import BookitGYLogoTransparent from "./assets/bookitgy-logo-transparent.png"
 import { Ionicons } from "@expo/vector-icons";
 import { SafeAreaProvider,SafeAreaView } from "react-native-safe-area-context";
 import ProviderPublicProfile from "./scr/components/ProviderPublicProfile";
 
 
 
 
@@ -2427,50 +2427,51 @@ function SearchScreen({
 
   const [filteredProviders, setFilteredProviders] = useState([]);
   const [searchQuery, setSearchQuery] = useState("");
   const [radiusKm, setRadiusKm] = useState(0); // 0 = any distance
   const [clientLocation, setClientLocation] = useState(null);
   const [locationError, setLocationError] = useState("");
   const [providers, setProviders] = useState([]);
   const [providersLoading, setProvidersLoading] = useState(true);
   const [providersError, setProvidersError] = useState("");
   const [selectedProvider, setSelectedProvider] = useState(null);
   const [services, setServices] = useState([]);
   const [servicesLoading, setServicesLoading] = useState(false);
   const [servicesError, setServicesError] = useState("");
   const [selectedService, setSelectedService] = useState(null);
   const [catalogImages, setCatalogImages] = useState([]);
   const [catalogLoading, setCatalogLoading] = useState(false);
   const [catalogError, setCatalogError] = useState("");
   const [availability, setAvailability] = useState([]);
   const [availabilityLoading, setAvailabilityLoading] = useState(false);
   const [availabilityError, setAvailabilityError] = useState("");
   const [selectedDate, setSelectedDate] = useState(null);
   const [selectedSlot, setSelectedSlot] = useState(null); // ISO string
   const [bookingLoading, setBookingLoading] = useState(false);
   const [hasSearched, setHasSearched] = useState(false); // ðŸ‘ˆ NEW
   const [refreshing, setRefreshing] = useState(false);
+  const hasAppliedSharedUsername = useRef(false);
 
   //Radius 
   const radiusOptions = [0, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100];
 
   const haversineKm = (lat1, lon1, lat2, lon2) => {
     if (
       lat1 == null ||
       lon1 == null ||
       lat2 == null ||
       lon2 == null
     ) {
       return null;
     }
     const toRad = (v) => (v * Math.PI) / 180;
     const R = 6371; // km
     const dLat = toRad(lat2 - lat1);
     const dLon = toRad(lon2 - lon1);
     const a =
       Math.sin(dLat / 2) * Math.sin(dLat / 2) +
       Math.cos(toRad(lat1)) *
         Math.cos(toRad(lat2)) *
         Math.sin(dLon / 2) *
         Math.sin(dLon / 2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
     return R * c;
@@ -2509,50 +2510,62 @@ function SearchScreen({
       return [];
     } finally {
       setProvidersLoading(false);
     }
   }, [showFlash, syncFavoritesFromList]);
 
   // Load providers on mount
   useEffect(() => {
     loadProviders();
   }, [loadProviders]);
 
   useEffect(() => {
     const providerFromNav = route?.params?.provider;
     if (!providerFromNav) return;
 
     const incomingId = getProviderId(providerFromNav);
     const currentId = getProviderId(selectedProvider);
     if (incomingId && incomingId === currentId) return;
 
     setSearchQuery(providerFromNav.name || "");
     setHasSearched(true);
     setFilteredProviders([providerFromNav]);
     handleSelectProvider(providerFromNav);
   }, [route?.params?.provider, selectedProvider, handleSelectProvider]);
 
+  useEffect(() => {
+    const sharedUsername = route?.params?.sharedUsername;
+    if (!sharedUsername || hasAppliedSharedUsername.current) return;
+
+    const trimmedUsername = `${sharedUsername}`.trim();
+    if (!trimmedUsername) return;
+
+    hasAppliedSharedUsername.current = true;
+    setSearchQuery(trimmedUsername);
+    setHasSearched(true);
+  }, [route?.params?.sharedUsername]);
+
   // Add a useEffect that recomputes filteredProviders
   // whenever providers/search/radius/location changes:
   useEffect(() => {
     // ðŸ‘‡ do nothing until the user actually searches or if the query is empty
     const trimmedQuery = searchQuery.trim();
     if (!hasSearched || !trimmedQuery) {
       setFilteredProviders([]);
       return;
     }
 
     const q = trimmedQuery.toLowerCase();
 
     const providerList = Array.isArray(providers) ? providers : [];
     const providerFromNav = route?.params?.provider;
     const navProviderId = getProviderId(providerFromNav);
     const navProviderName = (providerFromNav?.name || "").trim().toLowerCase();
 
     // If we navigated in with a specific provider, keep the results scoped
     // to that provider ID so namesakes don't appear.
     if (
       navProviderId &&
       navProviderName &&
       trimmedQuery.toLowerCase() === navProviderName
     ) {
       const exactMatch = providerList.find(
@@ -2977,51 +2990,55 @@ function SearchScreen({
                         {/* If user hasn't searched yet, show hint */}
                         {!hasSearched && (
                           <Text style={styles.serviceHint}>
                             Type a profession and press enter to search.
                           </Text>
                         )}
 
                         {/* Loading */}
                         {providersLoading && hasSearched && (
                           <View style={{ paddingVertical: 10 }}>
                             <ActivityIndicator />
                             <Text style={styles.serviceMeta}>Loading providersâ€¦</Text>
                           </View>
                         )}
 
                         {/* Error */}
                         {!providersLoading && providersError && hasSearched && (
                           <Text style={styles.errorText}>{providersError}</Text>
                         )}
 
                         {/* No results */}
                         {!providersLoading &&
                           !providersError &&
                           hasSearched &&
                           filteredProviders.length === 0 && (
-                            <Text style={styles.serviceHint}>No providers found.</Text>
+                            <Text style={styles.errorText}>
+                              {route?.params?.sharedUsername
+                                ? "Provider not found."
+                                : "No providers found."}
+                            </Text>
                           )}
 
                         {/* Results */}
                         {!providersLoading &&
                           !providersError &&
                           hasSearched &&
                           filteredProviders.length > 0 &&
                           filteredProviders.map((p) => {
                             const avatar = resolveImageUrl(
                               p.avatar_url || p.profile_photo_url
                             );
                             const favorite = isFavorite(p);
                     return (
                               <TouchableOpacity
                                 key={getProviderId(p) || p.name}
                                 style={[
                                   styles.serviceRow,
                                   selectedProvider &&
                                     getProviderId(selectedProvider) === getProviderId(p) && {
                                       backgroundColor: "#ecfdf3",
                                     },
                                 ]}
                                 onPress={() => handleSelectProvider(p)}
                               >
                                 <View
 
EOF
)