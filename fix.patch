 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/routes/admin.py b/backend/app/routes/admin.py
index abca7a56fb59cd7e22ea3d8e8ee9376a86d7bfc5..c3acdf62be6755b75210fe554b0e6e5fb180b90d 100644
--- a/backend/app/routes/admin.py
+++ b/backend/app/routes/admin.py
@@ -1,31 +1,31 @@
 import logging
 from datetime import date, datetime, time, timedelta
 from typing import List, Optional
 
 from fastapi import APIRouter, Body, Depends, HTTPException, Query
-from sqlalchemy import case, func
+from sqlalchemy import case, func, literal
 from sqlalchemy.orm import Session
 
 from app import crud, schemas, models
 from app.utils.email import send_billing_paid_email, send_provider_suspension_email
 from app.database import get_db
 from app.security import get_current_user_from_header
 
 router = APIRouter(prefix="/admin", tags=["admin"])
 logger = logging.getLogger(__name__)
 
 
 def _require_admin(current_user: models.User = Depends(get_current_user_from_header)) -> models.User:
     if not getattr(current_user, "is_admin", False):
         raise HTTPException(status_code=403, detail="Admin access required")
     return current_user
 
 
 @router.get("/service-charge", response_model=schemas.ServiceChargeOut)
 def get_service_charge(
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     pct = crud.get_platform_service_charge_percentage(db)
     return {"service_charge_percentage": float(pct)}
 
@@ -91,87 +91,96 @@ def get_signup_report(
     )
 
     total_providers, total_clients = (
         db.query(
             func.coalesce(
                 func.sum(case((models.User.is_provider.is_(True), 1), else_=0)),
                 0,
             ),
             func.coalesce(
                 func.sum(case((models.User.is_provider.is_(False), 1), else_=0)),
                 0,
             ),
         )
         .one()
     )
 
     return {
         "start": start,
         "end": end,
         "providers": int(providers_count or 0),
         "clients": int(clients_count or 0),
         "total_providers": int(total_providers or 0),
         "total_clients": int(total_clients or 0),
     }
 
+# Smoke test:
+# curl -H "Authorization: Bearer <token>" "https://<backend>/admin/reports/professions"
+# curl -H "Authorization: Bearer <token>" "https://<backend>/admin/reports/booking-metrics?start=2026-01-07&end=2026-01-13"
 
 @router.get("/reports/professions", response_model=schemas.AdminProfessionsOut)
 def list_professions(
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
-    rows = (
-        db.query(models.ProviderProfession.name)
-        .filter(models.ProviderProfession.name.isnot(None))
-        .distinct()
-        .order_by(models.ProviderProfession.name.asc())
-        .all()
-    )
-    professions = [row[0] for row in rows if row[0]]
+    professions = []
+    if hasattr(models, "ProviderProfession"):
+        rows = (
+            db.query(models.ProviderProfession.name)
+            .filter(models.ProviderProfession.name.isnot(None))
+            .distinct()
+            .order_by(models.ProviderProfession.name.asc())
+            .all()
+        )
+        professions = [row[0] for row in rows if row[0]]
     return {"professions": professions}
 
 
 @router.get("/reports/booking-metrics", response_model=schemas.AdminBookingMetricsOut)
 def get_booking_metrics(
     start: date = Query(...),
     end: date = Query(...),
     status: Optional[str] = Query(None),
     profession: Optional[str] = Query(None),
     db: Session = Depends(get_db),
     _: models.User = Depends(_require_admin),
 ):
     if start > end:
         raise HTTPException(status_code=400, detail="Start date must be on or before end date")
 
     start_ts = datetime.combine(start, time.min)
     end_ts_exclusive = datetime.combine(end + timedelta(days=1), time.min)
 
     normalized_status = (status or "all").strip().lower()
     normalized_profession = (profession or "all").strip()
 
     provider_ids_subquery = None
-    if normalized_profession and normalized_profession.lower() != "all":
+    if (
+        normalized_profession
+        and normalized_profession.lower() != "all"
+        and hasattr(models, "ProviderProfession")
+    ):
         provider_ids_subquery = (
             db.query(models.ProviderProfession.provider_id)
             .filter(models.ProviderProfession.name.ilike(normalized_profession))
             .subquery()
         )
 
     base_query = (
         db.query(models.Booking, models.Service, models.Provider, models.User)
         .join(models.Service, models.Booking.service_id == models.Service.id)
         .join(models.Provider, models.Service.provider_id == models.Provider.id)
         .join(models.User, models.Provider.user_id == models.User.id)
         .filter(models.Booking.start_time >= start_ts)
         .filter(models.Booking.start_time < end_ts_exclusive)
     )
 
     if provider_ids_subquery is not None:
         base_query = base_query.filter(models.Provider.id.in_(provider_ids_subquery))
 
     if normalized_status and normalized_status != "all":
         if normalized_status == "upcoming":
             base_query = base_query.filter(
                 models.Booking.status.in_(["confirmed", "pending"])
             )
         else:
             base_query = base_query.filter(models.Booking.status == normalized_status)
@@ -179,83 +188,86 @@ def get_booking_metrics(
     totals = (
         base_query.with_entities(
             func.count(models.Booking.id).label("total_bookings"),
             func.coalesce(
                 func.sum(
                     case(
                         (models.Booking.status.in_(["confirmed", "pending"]), 1),
                         else_=0,
                     )
                 ),
                 0,
             ).label("upcoming"),
             func.coalesce(
                 func.sum(case((models.Booking.status == "completed", 1), else_=0)),
                 0,
             ).label("completed"),
             func.coalesce(
                 func.sum(case((models.Booking.status == "cancelled", 1), else_=0)),
                 0,
             ).label("cancelled"),
             func.coalesce(func.sum(models.Service.price_gyd), 0.0).label("total_revenue"),
         )
         .one()
     )
 
-    profession_label = (
-        db.query(models.ProviderProfession.name)
-        .filter(models.ProviderProfession.provider_id == models.Provider.id)
-        .order_by(models.ProviderProfession.name.asc())
-        .limit(1)
-        .scalar_subquery()
-    )
+    profession_label = None
+    if hasattr(models, "ProviderProfession"):
+        profession_label = (
+            db.query(models.ProviderProfession.name)
+            .filter(models.ProviderProfession.provider_id == models.Provider.id)
+            .order_by(models.ProviderProfession.name.asc())
+            .limit(1)
+            .scalar_subquery()
+        )
+    profession_label_expr = profession_label if profession_label is not None else literal(None)
 
     provider_rows = (
         base_query.with_entities(
             models.Provider.id.label("provider_id"),
             models.User.username.label("provider_name"),
-            profession_label.label("profession"),
+            profession_label_expr.label("profession"),
             func.count(models.Booking.id).label("total_bookings"),
             func.coalesce(
                 func.sum(
                     case(
                         (models.Booking.status.in_(["confirmed", "pending"]), 1),
                         else_=0,
                     )
                 ),
                 0,
             ).label("upcoming"),
             func.coalesce(
                 func.sum(case((models.Booking.status == "completed", 1), else_=0)),
                 0,
             ).label("completed"),
             func.coalesce(
                 func.sum(case((models.Booking.status == "cancelled", 1), else_=0)),
                 0,
             ).label("cancelled"),
         )
-        .group_by(models.Provider.id, models.User.username, profession_label)
+        .group_by(models.Provider.id, models.User.username, profession_label_expr)
         .order_by(models.User.username.asc())
         .all()
     )
 
     return {
         "start": start,
         "end": end,
         "status": normalized_status or "all",
         "profession": normalized_profession or "all",
         "totals": {
             "total_bookings": int(totals.total_bookings or 0),
             "upcoming": int(totals.upcoming or 0),
             "completed": int(totals.completed or 0),
             "cancelled": int(totals.cancelled or 0),
             "total_revenue": float(totals.total_revenue or 0.0),
         },
         "by_provider": [
             {
                 "provider_id": row.provider_id,
                 "provider_name": row.provider_name,
                 "profession": row.profession,
                 "total_bookings": int(row.total_bookings or 0),
                 "upcoming": int(row.upcoming or 0),
                 "completed": int(row.completed or 0),
                 "cancelled": int(row.cancelled or 0),
 
EOF
)