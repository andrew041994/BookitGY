 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index e295b1e5a257f4a38117045af2d04543417e5b4d..29187ec5f2e81cf14620600e11f0e044653181d9 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -126,65 +126,80 @@ const createLinkingConfig = ({ isProvider }) => ({
       console.log("[deepLinking] Failed to parse path", path, error?.message || error);
       return undefined;
     }
   },
   async getInitialURL() {
     const url = await Linking.getInitialURL();
     return handleIncomingURL(url);
   },
   subscribe(listener) {
     const onReceiveURL = ({ url }) => {
       const safeUrl = handleIncomingURL(url);
       if (safeUrl) listener(safeUrl);
     };
 
     const subscription = Linking.addEventListener("url", onReceiveURL);
     return () => subscription.remove();
   },
 });
 
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
-  const resolveImageUrl = (url) => {
+const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
+const withTimeout = (promise, ms, label) => {
+  let timeoutId;
+  const timeout = new Promise((_, reject) => {
+    timeoutId = setTimeout(() => {
+      const error = new Error(`${label || "Operation"} timed out after ${ms}ms`);
+      error.code = "ETIMEDOUT";
+      reject(error);
+    }, ms);
+  });
+
+  return Promise.race([promise, timeout]).finally(() => {
+    clearTimeout(timeoutId);
+  });
+};
+
 const LEGACY_ACCESS_TOKEN_KEY = "accessToken";
 
 const getAuthToken = async (tokenState) => {
   if (tokenState?.token) return tokenState.token;
 
   try {
-    const secure = await loadToken();
+    const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY);
     return legacy || null;
   } catch (error) {
     console.log("[auth] Failed to load legacy token", error?.message || error);
     return null;
   }
 };
 
 const FAVORITES_STORAGE_KEY = (userKey) =>
   userKey ? `favoriteProviders:${userKey}` : "favoriteProviders";
 
 const getProviderId = (provider) =>
   provider?.provider_id ?? provider?.id ?? provider?._id ?? null;
 
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
@@ -6030,60 +6045,67 @@ function App() {
 
         if (!isApiRequest) return config;
 
         const authToken = await getAuthToken(tokenRef.current);
         if (authToken) {
           config.headers = {
             ...config.headers,
             Authorization: `Bearer ${authToken}`,
           };
         }
 
         return config;
       },
       (error) => Promise.reject(error)
     );
 
     return () => {
       axios.interceptors.request.eject(interceptorId);
     };
   }, []);
 
   useEffect(() => {
     let isActive = true;
     const restoreSession = async () => {
       try {
-        const restoredToken = await getAuthToken();
+        const restoredToken = await withTimeout(getAuthToken(), 2500, "getAuthToken");
         console.log("[auth] token loaded:", Boolean(restoredToken));
 
         if (!restoredToken) {
           if (isActive) setToken(null);
         } else {
           try {
-            const meRes = await axios.get(`${API}/users/me`, {
-              timeout: 10000,
-            });
+            const bootstrapClient = axios.create();
+            const meRes = await withTimeout(
+              bootstrapClient.get(`${API}/users/me`, {
+                headers: {
+                  Authorization: `Bearer ${restoredToken}`,
+                },
+              }),
+              12000,
+              "/users/me"
+            );
             if (isActive) {
               setToken({
                 token: restoredToken,
                 userId: meRes.data?.id || meRes.data?.user_id,
                 email: meRes.data?.email,
                 isProvider: Boolean(meRes.data?.is_provider),
                 isAdmin: Boolean(meRes.data?.is_admin),
               });
               setIsAdmin(Boolean(meRes.data?.is_admin));
             }
           } catch (err) {
             console.log(
               "[auth] Failed to load user info during bootstrap",
               err?.message || err
             );
             if (err?.response?.status === 401 || err?.response?.status === 403) {
               await clearToken();
               await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
               if (isActive) setToken(null);
             } else if (isActive) {
               setToken({ token: restoredToken });
             }
           }
         }
       } catch (err) {
 
EOF
)