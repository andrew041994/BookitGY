 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 7a8bb96222fae7cbb902879fa1c5ec5cd9bc9ef6..9b90e8e485c235756755ea7be4d53d8e0a52a980 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -88,75 +88,76 @@ const getProviderUsernameFromUrl = (url) => {
   } catch (error) {
     console.log("[deepLinking] Failed to parse URL", safeUrl, error?.message || error);
     return null;
   }
 };
 
 const withTimeout = (promise, ms, label) => {
   let timeoutId;
   const timeout = new Promise((_, reject) => {
     timeoutId = setTimeout(() => {
       const error = new Error(`${label || "Operation"} timed out after ${ms}ms`);
       error.code = "ETIMEDOUT";
       reject(error);
     }, ms);
   });
 
   return Promise.race([promise, timeout]).finally(() => {
     clearTimeout(timeoutId);
   });
 };
 
 const AUTH_BOOTSTRAP_WATCHDOG_MS = 15000;
 const AUTH_TOKEN_TIMEOUT_MS = 2000;
 const AUTH_ME_TIMEOUT_MS = 12000;
 
-const createLinkingConfig = ({ isProvider }) => ({
+const createLinkingConfig = ({ isProvider, isProviderRef }) => ({
   prefixes: ["https://bookitgy.com", "https://www.bookitgy.com", "bookitgy://"],
   config: {
     screens: {
       Home: "",
       Search: "search",
       PublicProfile: "public-profile/:username",
       Appointments: "appointments",
       Profile: "profile",
       Dashboard: "dashboard",
       Billing: "billing",
     },
   },
   getStateFromPath: (path, options) => {
     try {
       const trimmed = path?.replace(/^\//, "") || "";
       const firstSegment = trimmed.split("/")[0];
 
       if (RESERVED_USERNAME_PATHS.has(firstSegment)) {
         return defaultGetStateFromPath("/profile", options);
       }
 
       const username = getProviderUsernameFromPath(path);
       if (username) {
-        const targetPath = isProvider
+        const providerStatus = isProviderRef?.current ?? isProvider;
+        const targetPath = providerStatus
           ? `/public-profile/${encodeURIComponent(username)}`
           : `/search?username=${encodeURIComponent(username)}`;
         return defaultGetStateFromPath(targetPath, options);
       }
 
       return defaultGetStateFromPath(path, options);
     } catch (error) {
       console.log("[deepLinking] Failed to parse path", path, error?.message || error);
       return undefined;
     }
   },
   async getInitialURL() {
     try {
       const url = await withTimeout(Linking.getInitialURL(), 1500, "getInitialURL");
       return handleIncomingURL(url);
     } catch (error) {
       console.log("[deepLinking] Failed to get initial URL", error?.message || error);
       return null;
     }
   },
   subscribe(listener) {
     const onReceiveURL = ({ url }) => {
       const safeUrl = handleIncomingURL(url);
       if (safeUrl) listener(safeUrl);
     };
@@ -5779,104 +5780,110 @@ function ProviderBillingScreen({ token, showFlash }) {
           </View>
         ))}
     </ScrollView>
   );
 }
 
 
 // Tabs after login
 function MainApp({ token, setToken, showFlash, navigationRef, onNavReady }) {
    const {
     favoriteIds,
     favoriteProviders,
     favoritesLoading,
     toggleFavorite,
     isFavorite,
     syncFavoritesFromList,
     refreshFavoriteProviders,
   } = useFavoriteProviders(token?.email || token?.userId);
   const [linkingEnabled, setLinkingEnabled] = useState(true);
   const [navReady, setNavReady] = useState(false);
   const [fallbackSeconds, setFallbackSeconds] = useState(0);
   const [fallbackStartedAt, setFallbackStartedAt] = useState(null);
   const navReadyRef = useRef(false);
   const fallbackTimeoutRef = useRef(null);
   const fallbackIntervalRef = useRef(null);
-  const linking = useMemo(
-    () => createLinkingConfig({ isProvider: token?.isProvider }),
-    [token?.isProvider]
-  );
+  const linkingRef = useRef(null);
+  const isProviderRef = useRef(token?.isProvider);
+
+  useEffect(() => {
+    isProviderRef.current = token?.isProvider;
+  }, [token?.isProvider]);
+
+  if (!linkingRef.current) {
+    linkingRef.current = createLinkingConfig({ isProviderRef });
+  }
 
   const clearFallbackTimer = useCallback(() => {
     if (fallbackTimeoutRef.current) {
       clearTimeout(fallbackTimeoutRef.current);
       fallbackTimeoutRef.current = null;
     }
     if (fallbackIntervalRef.current) {
       clearInterval(fallbackIntervalRef.current);
       fallbackIntervalRef.current = null;
     }
   }, []);
 
   useEffect(() => {
     navReadyRef.current = false;
     setNavReady(false);
     if (!linkingEnabled) {
       clearFallbackTimer();
       setFallbackStartedAt(null);
       setFallbackSeconds(0);
       return;
     }
 
     const startTime = Date.now();
     setFallbackStartedAt(startTime);
     setFallbackSeconds(0);
 
     fallbackTimeoutRef.current = setTimeout(() => {
       if (!navReadyRef.current) {
         console.warn(
           "[navigation] onReady did not fire in time, disabling linking fallback."
         );
         setLinkingEnabled(false);
       }
     }, 5000);
 
     fallbackIntervalRef.current = setInterval(() => {
       setFallbackSeconds(Math.floor((Date.now() - startTime) / 1000));
     }, 1000);
 
     return () => {
       clearFallbackTimer();
     };
   }, [clearFallbackTimer, linkingEnabled]);
   return (
 
     // add this later linking={linking}
     <NavigationContainer
       ref={navigationRef}
       key={`nav-${linkingEnabled ? "linking" : "nolinking"}`}
-      linking={linkingEnabled ? linking : undefined}
+      linking={linkingEnabled ? linkingRef.current : undefined}
       fallback={
         <View style={styles.center}>
           <ActivityIndicator size="large" color="#0B6BF2" />
           <Text style={styles.loadingText}>Loading BookitGYâ€¦</Text>
           <Text style={styles.loadingText}>
             fallback: linkingEnabled={linkingEnabled ? "true" : "false"}
           </Text>
           <Text style={styles.loadingText}>
             fallback timer: {fallbackStartedAt ? `${fallbackSeconds}s` : "inactive"}
           </Text>
         </View>
       }
       onReady={() => {
         navReadyRef.current = true;
         setNavReady(true);
         clearFallbackTimer();
         if (onNavReady) onNavReady();
       }}
     >
       {token.isProvider ? (
         // ðŸ‘‡ Provider view: Dashboard + Billing + Profile
         <Tab.Navigator
           initialRouteName="Dashboard"
           screenOptions={({ route }) => ({
             headerShown: false,
 
EOF
)