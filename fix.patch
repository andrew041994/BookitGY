 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 81be0e080bb228b4fdd91134212f8bab023b9472..effcc88f81a9f23aa862c8e78f303453bbf665e4 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -1,50 +1,55 @@
 import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
-import { useFocusEffect } from "@react-navigation/native";
 import {
   Text,
   View,
   StyleSheet,
   TextInput,
   Button,
   Alert,
   ActivityIndicator,
   ScrollView,
   TouchableOpacity,
   Switch,
   Linking,
   Platform,
   Image,
   KeyboardAvoidingView,
   TouchableWithoutFeedback,
   Keyboard,
   Pressable,
   RefreshControl,
   Share,
   AppState,
 } from "react-native";
-import { NavigationContainer } from "@react-navigation/native";
+import {
+  NavigationContainer,
+  CommonActions,
+  TabActions,
+  useFocusEffect,
+  useIsFocused,
+} from "@react-navigation/native";
 import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
 import { enableScreens } from "react-native-screens";
 import axios from "axios";
 import AsyncStorage from "@react-native-async-storage/async-storage";
 import { clearToken, loadToken, saveToken } from "./src/components/tokenStorage";
 import ProviderCard from "./src/components/ProviderCard";
 import { createApiClient } from "./src/api/client";
 import * as Location from "expo-location";
 import Constants from "expo-constants";
 import * as ImagePicker from "expo-image-picker";
 import { Ionicons } from "@expo/vector-icons";
 import { SafeAreaProvider,SafeAreaView } from "react-native-safe-area-context";
 import BookitGYLogoTransparent from "./assets/bookitgy-logo-transparent.png"
 import { theme } from "./src/theme";
 // import * as Sentry from "sentry-expo";
 
 let Clipboard = null;
 try {
   Clipboard = require("expo-clipboard");
 } catch (e) {}
 
 enableScreens(false);
 
 
 
@@ -72,50 +77,56 @@ const withTimeout = (promise, ms, label) => {
       error.code = "ETIMEDOUT";
       reject(error);
     }, ms);
   });
 
   return Promise.race([promise, timeout]).finally(() => {
     clearTimeout(timeoutId);
   });
 };
 
 const AUTH_BOOTSTRAP_WATCHDOG_MS = 15000;
 const AUTH_TOKEN_TIMEOUT_MS = 2000;
 const AUTH_ME_TIMEOUT_MS = 12000;
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
 const isValidUsername = (value) => {
   const trimmed = String(value || "").trim();
   if (!trimmed) return false;
   return /^[a-zA-Z0-9._-]+$/.test(trimmed);
 };
 
+const normalizeSearchValue = (value) =>
+  String(value || "")
+    .replace(/[\u200B-\u200D\uFEFF]/g, "")
+    .trim()
+    .toLowerCase();
+
 const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
 const LEGACY_ACCESS_TOKEN_KEY = "accessToken";
 
 const getAuthToken = async (tokenState) => {
   if (tokenState?.token) return tokenState.token;
 
   try {
     const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await withTimeout(
       AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY),
       1500,
       "loadLegacyToken"
@@ -179,65 +190,59 @@ function extractUsernameFromUrl(url) {
     username = segments[1];
   } else if (segments.length === 1 && !RESERVED_USERNAME_PATHS.has(segments[0])) {
     username = segments[0];
   }
 
   if (!username) return null;
 
   let decoded = username;
   try {
     decoded = decodeURIComponent(username);
   } catch (error) {
     decoded = username;
   }
 
   const cleaned = decoded.trim().replace(/^@/, "");
   if (!cleaned || !isValidUsername(cleaned)) return null;
   return cleaned;
 }
 
 function buildProviderPublicLink(username) {
   const trimmed = String(username || "").trim();
   if (!trimmed) return null;
   return `https://bookitgy.com/u/${encodeURIComponent(trimmed)}`;
 }
 
-function navigateToClientSearch(username, navigationRef) {
+function navigateToClientSearch(username, navigationRef, nonce) {
   if (!navigationRef?.current) return false;
 
-  const params = { incomingUsername: username, deeplinkNonce: Date.now() };
-
-  navigationRef.current.reset({
-    index: 1,
-    routes: [
-      { name: "Home" },
-      { name: "Search", params },
-      { name: "Appointments" },
-      { name: "Profile" },
-    ],
-  });
-
+  const params = { incomingUsername: username, deeplinkNonce: nonce ?? Date.now() };
+  console.log("[deeplink] navigateToClientSearch", username, params.deeplinkNonce);
+  navigationRef.current.dispatch(TabActions.jumpTo("Search", params));
+  navigationRef.current.dispatch(
+    CommonActions.navigate({ name: "Search", params })
+  );
   return true;
 }
 
 
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
 
   const persistIds = useCallback(async (ids) => {
     try {
       await AsyncStorage.setItem(storageKey, JSON.stringify(ids));
     } catch (err) {
       console.log("Error saving favorites", err?.message || err);
     }
   }, [storageKey]);
 
   const loadFavoritesFromStorage = useCallback(async () => {
     try {
       setFavoritesLoading(true);
       const raw = await AsyncStorage.getItem(storageKey);
       const parsed = raw ? JSON.parse(raw) : [];
       setFavoriteIds(Array.isArray(parsed) ? parsed : []);
     } catch (err) {
@@ -2718,61 +2723,68 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
   const [filteredProviders, setFilteredProviders] = useState([]);
   const [searchQuery, setSearchQuery] = useState("");
   const [radiusKm, setRadiusKm] = useState(0); // 0 = any distance
   const [clientLocation, setClientLocation] = useState(null);
   const [locationError, setLocationError] = useState("");
   const [providers, setProviders] = useState([]);
   const [providersLoading, setProvidersLoading] = useState(true);
   const [providersError, setProvidersError] = useState("");
   const [selectedProvider, setSelectedProvider] = useState(null);
   const [services, setServices] = useState([]);
   const [servicesLoading, setServicesLoading] = useState(false);
   const [servicesError, setServicesError] = useState("");
   const [selectedService, setSelectedService] = useState(null);
   const [catalogImages, setCatalogImages] = useState([]);
   const [catalogLoading, setCatalogLoading] = useState(false);
   const [catalogError, setCatalogError] = useState("");
   const [availability, setAvailability] = useState([]);
   const [availabilityLoading, setAvailabilityLoading] = useState(false);
   const [availabilityError, setAvailabilityError] = useState("");
   const [selectedDate, setSelectedDate] = useState(null);
   const [selectedSlot, setSelectedSlot] = useState(null); // ISO string
   const [bookingLoading, setBookingLoading] = useState(false);
   const [hasSearched, setHasSearched] = useState(false); // ðŸ‘ˆ NEW
   const [refreshing, setRefreshing] = useState(false);
   const [shouldScrollToResults, setShouldScrollToResults] = useState(false);
+  const isFocused = useIsFocused();
   const scrollRef = useRef(null);
   const resultsOffset = useRef(0);
   //Radius 
   const distanceChips = [0, 5, 10, 15, 20];
 
   useEffect(() => {
+    if (!isFocused) return;
     if (!incomingUsername) return;
+    console.log(
+      "[deeplink] consumed in SearchScreen",
+      incomingUsername,
+      deeplinkNonce
+    );
     setSearchQuery(incomingUsername);
     setHasSearched(true);
     setShouldScrollToResults(true);
-  }, [incomingUsername, deeplinkNonce]);
+  }, [isFocused, incomingUsername, deeplinkNonce]);
 
   const haversineKm = (lat1, lon1, lat2, lon2) => {
     if (
       lat1 == null ||
       lon1 == null ||
       lat2 == null ||
       lon2 == null
     ) {
       return null;
     }
     const toRad = (v) => (v * Math.PI) / 180;
     const R = 6371; // km
     const dLat = toRad(lat2 - lat1);
     const dLon = toRad(lon2 - lon1);
     const a =
       Math.sin(dLat / 2) * Math.sin(dLat / 2) +
       Math.cos(toRad(lat1)) *
         Math.cos(toRad(lat2)) *
         Math.sin(dLon / 2) *
         Math.sin(dLon / 2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
     return R * c;
   };
 
 
@@ -2813,88 +2825,95 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
   }, [showFlash, syncFavoritesFromList]);
 
   // Load providers on mount
   useEffect(() => {
     loadProviders();
   }, [loadProviders]);
 
   useEffect(() => {
     const providerFromNav = route?.params?.provider;
     if (!providerFromNav) return;
 
     const incomingId = getProviderId(providerFromNav);
     const currentId = getProviderId(selectedProvider);
     if (incomingId && incomingId === currentId) return;
 
     setSearchQuery(providerFromNav.name || "");
     setHasSearched(true);
     setFilteredProviders([providerFromNav]);
     handleSelectProvider(providerFromNav);
   }, [route?.params?.provider, selectedProvider, handleSelectProvider]);
 
   // Add a useEffect that recomputes filteredProviders
   // whenever providers/search/radius/location changes:
   useEffect(() => {
     // ðŸ‘‡ do nothing until the user actually searches or if the query is empty
-    const trimmedQuery = searchQuery.trim();
-    if (!hasSearched || !trimmedQuery) {
+    const normalizedQuery = normalizeSearchValue(searchQuery);
+    if (!hasSearched || !normalizedQuery) {
       setFilteredProviders([]);
       return;
     }
 
     const providerList = Array.isArray(providers) ? providers : [];
-    const deeplinkUsername = (incomingUsername || "").trim().toLowerCase();
+    const deeplinkUsername = normalizeSearchValue(incomingUsername);
     if (
       deeplinkUsername &&
-      trimmedQuery.toLowerCase() === deeplinkUsername
+      normalizedQuery === deeplinkUsername
     ) {
+      console.log(
+        "[search] deeplink exact attempt",
+        deeplinkUsername
+      );
       const exact = providerList.filter((p) => {
-        const u1 = (p.username || "").trim().toLowerCase();
-        const u2 = (p.user?.username || "").trim().toLowerCase();
+        const u1 = normalizeSearchValue(p.username);
+        const u2 = normalizeSearchValue(p.user?.username);
         return u1 === deeplinkUsername || u2 === deeplinkUsername;
       });
       console.log(
         "[search] deeplink exact username",
         deeplinkUsername,
         "matches",
         exact.length
       );
-      setFilteredProviders(exact);
-      return;
+      if (exact.length > 0) {
+        setFilteredProviders(exact);
+        return;
+      }
+      console.log("[search] deeplink exact miss, falling back to fuzzy");
     }
 
-    const q = trimmedQuery.toLowerCase();
+    const q = normalizedQuery;
     const providerFromNav = route?.params?.provider;
     const navProviderId = getProviderId(providerFromNav);
-    const navProviderName = (providerFromNav?.name || "").trim().toLowerCase();
+    const navProviderName = normalizeSearchValue(providerFromNav?.name);
 
     // If we navigated in with a specific provider, keep the results scoped
     // to that provider ID so namesakes don't appear.
     if (
       navProviderId &&
       navProviderName &&
-      trimmedQuery.toLowerCase() === navProviderName
+      normalizedQuery === navProviderName
     ) {
       const exactMatch = providerList.find(
         (p) => getProviderId(p) === navProviderId
       );
 
       setFilteredProviders([exactMatch || providerFromNav]);
       return;
     }
 
     let list = providerList.map((p) => {
       let distance_km = null;
       if (clientLocation && p.lat != null && p.long != null) {
         distance_km = haversineKm(
           clientLocation.lat,
           clientLocation.long,
           p.lat,
           p.long
         );
       }
       return { ...p, distance_km };
     });
 
     // text filter (profession/name/location)
     if (q) {
       list = list.filter((p) => {
@@ -6079,51 +6098,51 @@ function FlashMessage({ flash }) {
     </View>
   );
 }
 
 
 // ðŸ”¹ App orchestrates landing/login/signup/forgot-password vs main app
 
 const DEEPLINK_DEBUG = true;
 
 function App() {
 
   const mountIdRef = useRef(Math.random().toString(16).slice(2));
   console.log("APP MOUNT ID:", mountIdRef.current);
   useEffect(() => console.log("APP useEffect ran for mount", mountIdRef.current), []);
 
   const [token, setToken] = useState(null);
   const [authLoading, setAuthLoading] = useState(true);
   const [authMode, setAuthMode] = useState("landing"); // 'landing' | 'login' | 'signup' | 'forgot'
   const [isAdmin, setIsAdmin] = useState(false);
   const [pendingDeepLinkUsername, setPendingDeepLinkUsername] = useState(null);
   const [navReady, setNavReady] = useState(false);
   const navReadyRef = useRef(false);
   const navigationRef = useRef(null);
   const authBootstrapRef = useRef({ inFlight: false, completed: false });
   const tokenRef = useRef(token);
-  const lastHandledUrlRef = useRef(null);
+  const lastDeeplinkHandledAtRef = useRef(0);
 
   const [flash, setFlash] = useState(null);
   const handleUnauthorized = useCallback(async () => {
     try {
       await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
     } catch (storageError) {
       console.log(
         "[auth] Failed to clear legacy token",
         storageError?.message || storageError
       );
     }
     setToken(null);
   }, []);
 
   const apiClient = useMemo(
     () =>
       createApiClient({
         baseURL: API,
         onUnauthorized: handleUnauthorized,
       }),
     [handleUnauthorized]
   );
 
 
 
@@ -6168,131 +6187,119 @@ function App() {
     }, 4500);
   }, [formatFlashText]);
 
   useEffect(() => {
     tokenRef.current = token;
   }, [token]);
 
   useEffect(() => {
     navReadyRef.current = navReady;
   }, [navReady]);
 
   useEffect(() => {
     if (!token) setNavReady(false);
   }, [token]);
 
   const handleIncomingUrl = useCallback((url, source) => {
     console.log("[deeplink] handleIncomingUrl", source, url);
     if (DEEPLINK_DEBUG) showFlash("info", `[DL] ${source}: ${url || "(null)"}`);
     const username = extractUsernameFromUrl(url);
     console.log("[deeplink] extracted username", username);
     if (!username) {
       if (DEEPLINK_DEBUG) showFlash("error", "[DL] parse failed");
       return false;
     }
     if (DEEPLINK_DEBUG) showFlash("success", `[DL] user: ${username}`);
-    if (url) {
-      lastHandledUrlRef.current = url;
-    }
+    lastDeeplinkHandledAtRef.current = Date.now();
 
     if (tokenRef.current?.isProvider === true) {
       showFlash("error", "Open as a client to view provider links.");
       return true;
     }
 
-    if (
-      tokenRef.current &&
-      tokenRef.current.isProvider === false &&
-      navReadyRef.current === true &&
-      navigationRef.current
-    ) {
-      if (DEEPLINK_DEBUG) showFlash("success", `[DL] nav Search: ${username}`);
-      navigateToClientSearch(username, navigationRef);
-      setPendingDeepLinkUsername(null);
-      return true;
-    }
-
-    setPendingDeepLinkUsername({ username, nonce: Date.now() });
+    const queued = { username, nonce: Date.now() };
+    console.log("[deeplink] queued", queued.username, queued.nonce);
+    setPendingDeepLinkUsername(queued);
     return true;
   }, [showFlash]);
 
   useEffect(() => {
     let isActive = true;
 
     Linking.getInitialURL().then((url) => {
       if (!isActive) return;
       console.log("[deeplink] getInitialURL", url);
       if (DEEPLINK_DEBUG) {
         showFlash("info", `[DL] getInitialURL: ${url || "(null)"}`);
       }
-      if (url && url !== lastHandledUrlRef.current) {
-        handleIncomingUrl(url, "initial");
-      }
+      if (url) handleIncomingUrl(url, "initial");
     });
 
     const sub = Linking.addEventListener("url", ({ url }) => {
+      console.log("[deeplink] url event", url);
       handleIncomingUrl(url, "event");
     });
 
     return () => {
       isActive = false;
       sub.remove();
     };
   }, [handleIncomingUrl]);
 
   useEffect(() => {
     const sub = AppState.addEventListener("change", (nextState) => {
       if (nextState !== "active") return;
+      const now = Date.now();
+      if (now - lastDeeplinkHandledAtRef.current < 500) {
+        return;
+      }
       Linking.getInitialURL().then((url) => {
-        console.log("[deeplink] getInitialURL (active)", url);
-        if (DEEPLINK_DEBUG) {
-          showFlash("info", `[DL] getInitialURL(active): ${url || "(null)"}`);
-        }
-        if (!url || url === lastHandledUrlRef.current) return;
+        if (!url) return;
         handleIncomingUrl(url, "appstate-active");
       });
     });
 
     return () => {
       sub.remove();
     };
   }, [handleIncomingUrl]);
 
   useEffect(() => {
     if (!pendingDeepLinkUsername) return;
     if (!token) return;
     if (token.isProvider) {
       showFlash("error", "Open as a client to view provider links.");
       setPendingDeepLinkUsername(null);
       return;
     }
     if (!navReady) return;
     if (!navigationRef.current) return;
 
     const ok = navigateToClientSearch(
       pendingDeepLinkUsername.username,
-      navigationRef
+      navigationRef,
+      pendingDeepLinkUsername.nonce
     );
     console.log(
       "[deeplink] pending navigate attempt",
       pendingDeepLinkUsername.username,
       "ok",
       ok
     );
     if (ok) setPendingDeepLinkUsername(null);
   }, [pendingDeepLinkUsername, token, navReady, showFlash]);
 
   useEffect(() => {
     let isActive = true;
     const restoreSession = async () => {
       if (authBootstrapRef.current.inFlight || authBootstrapRef.current.completed) {
         return;
       }
       authBootstrapRef.current.inFlight = true;
       const bootstrapStartedAt = Date.now();
       console.log("[auth] bootstrap start");
       try {
         const restoredToken = await withTimeout(
           getAuthToken(),
           AUTH_TOKEN_TIMEOUT_MS,
           "getAuthToken"
         );
 
EOF
)