 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 8ac301233e5145244adff8da946f67077d82c508..ac575acf92883876c0913a857f490782afe15625 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -7003,50 +7003,57 @@ function WeeklyStrip({
                   {day.dayNumber}
                 </Text>
               </View>
               {hasBookings ? (
                 <View
                   style={[
                     styles.providerWeeklyDot,
                     {
                       backgroundColor: allCompleted ? colors.textMuted : colors.primary,
                     },
                   ]}
                 />
               ) : null}
             </Pressable>
           );
         })}
       </View>
     </View>
   );
 }
 
 
 
 
 function ProviderCalendarScreen({ token, showFlash }) {
+  // Manual checklist:
+  // - confirmed booking shows Cancel
+  // - cancelled/completed booking hides Cancel
+  // - tapping Cancel prompts confirm
+  // - confirm triggers request
+  // - success refreshes and shows toast
+  // - failure shows toast
   // Keep the calendar in fixed-height view wrappers so it cannot expand into the appointments header/list area.
   const WEEKLY_FIRST_DAY = 1;
   const PROVIDER_CALENDAR_DEBUG = false;
   const parseLocalMidday = useCallback((dateKey) => {
     if (typeof dateKey !== "string") return null;
     const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateKey);
     if (!match) return null;
     const [, yyyyStr, mmStr, ddStr] = match;
     const yyyy = Number(yyyyStr);
     const mm = Number(mmStr);
     const dd = Number(ddStr);
     if (!Number.isInteger(yyyy) || !Number.isInteger(mm) || !Number.isInteger(dd)) return null;
     const parsed = new Date(yyyy, mm - 1, dd, 12, 0, 0);
     if (Number.isNaN(parsed.getTime())) return null;
     return parsed;
   }, []);
   const normalizeDateKey = useCallback((dateLike) => {
     if (!dateLike) return null;
     let parsed = null;
     if (dateLike instanceof Date) {
       parsed = dateLike;
     } else if (typeof dateLike === "string") {
       if (/^\d{4}-\d{2}-\d{2}$/.test(dateLike)) {
         parsed = parseLocalMidday(dateLike);
       } else if (dateLike.includes("T")) {
@@ -7079,50 +7086,51 @@ function ProviderCalendarScreen({ token, showFlash }) {
   const getWeekDays = useCallback((weekStartKey) => {
     const weekdayLabels = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
     const start = parseLocalMidday(weekStartKey);
     if (!start) return [];
 
     return Array.from({ length: 7 }, (_, index) => {
       const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + index, 12, 0, 0);
       const yyyy = current.getFullYear();
       const mm = String(current.getMonth() + 1).padStart(2, "0");
       const dd = String(current.getDate()).padStart(2, "0");
       return {
         key: `${yyyy}-${mm}-${dd}`,
         label: weekdayLabels[index],
         dayNumber: String(current.getDate()),
       };
     });
   }, [parseLocalMidday]);
   const [viewMode, setViewMode] = useState("month");
   const [selectedDate, setSelectedDate] = useState(() => normalizeDateKey(new Date()) || "");
   const [weekStartKey, setWeekStartKey] = useState(() => {
     const todayKey = normalizeDateKey(new Date()) || "";
     return startOfWeekKey(todayKey) || todayKey;
   });
   const [weekPagerWidth, setWeekPagerWidth] = useState(0);
   const [bookingsByDate, setBookingsByDate] = useState({});
+  const [cancellingByBookingId, setCancellingByBookingId] = useState({});
   const [loading, setLoading] = useState(false);
   const [error, setError] = useState("");
   const [refreshing, setRefreshing] = useState(false);
   const weekPagerRef = useRef(null);
 
   const dateRange = useMemo(() => {
     const base = new Date(`${selectedDate}T12:00:00`);
     const monthStart = new Date(base.getFullYear(), base.getMonth(), 1);
     const monthEnd = new Date(base.getFullYear(), base.getMonth() + 1, 0);
     return {
       start: normalizeDateKey(monthStart),
       end: normalizeDateKey(monthEnd),
     };
   }, [normalizeDateKey, selectedDate]);
 
   const formatDayKey = useCallback((bookingStartTime) => normalizeDateKey(bookingStartTime), [normalizeDateKey]);
 
   useEffect(() => {
     const nextWeekStart = startOfWeekKey(selectedDate);
     if (nextWeekStart) {
       setWeekStartKey(nextWeekStart);
     }
   }, [selectedDate, startOfWeekKey]);
 
   const weekPages = useMemo(() => {
@@ -7171,99 +7179,183 @@ function ProviderCalendarScreen({ token, showFlash }) {
     const normalizedStatus = String(booking?.status || booking?.state || "")
       .trim()
       .toLowerCase();
 
     const isCancelled =
       normalizedStatus === "cancelled" ||
       normalizedStatus === "canceled" ||
       Boolean(booking?.cancelled_at || booking?.canceled_at || booking?.is_cancelled || booking?.isCanceled);
 
     if (isCancelled) {
       return { type: "cancelled", label: "Cancelled" };
     }
 
     const isCompleted =
       normalizedStatus === "completed" ||
       Boolean(booking?.completed_at || booking?.is_completed) ||
       isBookingCompleted(booking);
 
     if (isCompleted) {
       return { type: "completed", label: "Completed" };
     }
 
     return { type: "scheduled", label: "Scheduled" };
   }, [isBookingCompleted]);
 
+  const getBookingId = useCallback(
+    (booking) => String(booking?.id || booking?.booking_id || ""),
+    []
+  );
+
+  const isBookingCancellable = useCallback(
+    (booking) => {
+      const status = getBookingStatusLabel(booking);
+      if (status.type === "cancelled" || status.type === "completed") return false;
+
+      const normalizedStatus = String(booking?.status || booking?.state || "")
+        .trim()
+        .toLowerCase();
+
+      return normalizedStatus === "confirmed";
+    },
+    [getBookingStatusLabel]
+  );
+
   const loadBookingsForRange = useCallback(async (useRefresh = false) => {
     try {
       if (useRefresh) setRefreshing(true);
       setLoading(true);
       setError("");
 
       const authToken = await getAuthToken(token);
       if (!authToken) {
         setError("No access token found. Please log in again.");
         return;
       }
 
       const res = await axios.get(`${API}/providers/me/bookings`, {
         headers: {
           Authorization: `Bearer ${authToken}`,
         },
         params: {
           start: dateRange.start,
           end: dateRange.end,
         },
       });
 
       const rows = Array.isArray(res.data)
         ? res.data
         : res.data?.bookings || res.data?.results || [];
 
       const grouped = rows.reduce((acc, booking) => {
         const key = formatDayKey(booking?.start_time);
         if (!key) return acc;
         if (!acc[key]) acc[key] = [];
         acc[key].push(booking);
         return acc;
       }, {});
 
       setBookingsByDate(grouped);
     } catch (err) {
       console.log("Error loading provider calendar bookings", err?.response?.data || err?.message || err);
       setError("Could not load calendar bookings.");
       if (showFlash) {
         showFlash("error", "Could not load calendar bookings.");
       }
     } finally {
       setLoading(false);
       if (useRefresh) setRefreshing(false);
     }
   }, [dateRange.end, dateRange.start, formatDayKey, showFlash, token]);
 
   const handleRefresh = useCallback(() => loadBookingsForRange(true), [loadBookingsForRange]);
 
+  const handleCancelAppointment = useCallback(
+    (booking) => {
+      const bookingId = getBookingId(booking);
+      if (!bookingId || cancellingByBookingId[bookingId]) return;
+
+      Alert.alert(
+        "Cancel appointment?",
+        "This will notify the customer.",
+        [
+          { text: "Keep", style: "cancel" },
+          {
+            text: "Cancel appointment",
+            style: "destructive",
+            onPress: async () => {
+              if (cancellingByBookingId[bookingId]) return;
+
+              setCancellingByBookingId((prev) => ({ ...prev, [bookingId]: true }));
+              try {
+                const authToken = await getAuthToken(token);
+                if (!authToken) {
+                  if (showFlash) showFlash("error", "No access token found. Please log in again.");
+                  return;
+                }
+
+                await axios.post(
+                  `${API}/providers/me/bookings/${bookingId}/cancel`,
+                  {},
+                  {
+                    headers: {
+                      Authorization: `Bearer ${authToken}`,
+                    },
+                  }
+                );
+
+                setBookingsByDate((prev) => {
+                  const next = { ...prev };
+                  Object.keys(next).forEach((dayKey) => {
+                    next[dayKey] = (next[dayKey] || []).map((item) =>
+                      getBookingId(item) === bookingId
+                        ? { ...item, status: "cancelled", canceled_at: new Date().toISOString(), canceled_by_role: "provider" }
+                        : item
+                    );
+                  });
+                  return next;
+                });
+
+                if (showFlash) showFlash("success", "Appointment cancelled");
+                await loadBookingsForRange();
+              } catch (err) {
+                const message =
+                  err?.response?.data?.detail ||
+                  err?.response?.data?.message ||
+                  "Could not cancel appointment. Please try again.";
+                if (showFlash) showFlash("error", message);
+              } finally {
+                setCancellingByBookingId((prev) => ({ ...prev, [bookingId]: false }));
+              }
+            },
+          },
+        ]
+      );
+    },
+    [cancellingByBookingId, getBookingId, loadBookingsForRange, showFlash, token]
+  );
+
   useEffect(() => {
     loadBookingsForRange();
   }, [loadBookingsForRange]);
 
   const selectedBookings = useMemo(() => bookingsByDate[selectedDate] || [], [bookingsByDate, selectedDate]);
   const sortedSelectedBookings = useMemo(
     () =>
       selectedBookings
         .slice()
         .sort((a, b) => new Date(a?.start_time || a?.start) - new Date(b?.start_time || b?.start)),
     [selectedBookings]
   );
 
   const formatTimelineTime = useCallback((isoDateLike) => {
     const parsed = new Date(isoDateLike);
     if (Number.isNaN(parsed.getTime())) return "--:--";
     const hh = String(parsed.getHours()).padStart(2, "0");
     const mm = String(parsed.getMinutes()).padStart(2, "0");
     return `${hh}:${mm}`;
   }, []);
 
   const getEventAccentColor = useCallback((booking) => {
     const palette = [colors.primary, "#1CA7A8", "#4C8BF5", "#8A63D2"];
     const hashSource = String(booking?.service_id || booking?.service_name || "service");
     const hash = Array.from(hashSource).reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
@@ -7378,110 +7470,130 @@ function ProviderCalendarScreen({ token, showFlash }) {
     () =>
       timelineEvents
         .map((event) => {
           const startDate = new Date(event.start);
           const endDate = new Date(event.end);
           if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) return null;
           return {
             ...event,
             startDate,
             endDate,
           };
         })
         .filter(Boolean),
     [timelineEvents]
   );
 
   const appointmentListData = viewMode !== "day" ? sortedSelectedBookings : [];
   const showAppointmentsEmptyState = viewMode !== "day";
 
   return (
     <SafeAreaView style={styles.providerCalendarScreen} edges={["left", "right", "bottom"]}>
       <View style={styles.providerCalendarContentContainer}>
         <FlatList
           data={appointmentListData}
           keyExtractor={(booking) =>
-            String(
-              booking?.id ||
-                booking?.booking_id ||
-                `${booking?.start_time || booking?.start}-${booking?.service_name || "service"}`
-            )
+            getBookingId(booking) || `${booking?.start_time || booking?.start}-${booking?.service_name || "service"}`
           }
           renderItem={({ item: booking }) => {
+            const bookingId = getBookingId(booking);
             const status = getBookingStatusLabel(booking);
             const completed = status.type === "completed";
+            const isCancelling = !!(bookingId && cancellingByBookingId[bookingId]);
+            const canCancel = isBookingCancellable(booking);
             const startIso = booking?.start_time || booking?.start;
             const startLabel = startIso
               ? new Date(startIso).toLocaleTimeString([], {
                   hour: "numeric",
                   minute: "2-digit",
                 })
               : "--:--";
 
             return (
               <View
                 style={[
                   styles.providerCalendarRow,
                   completed && styles.providerCalendarRowCompleted,
                 ]}
               >
                 <View style={{ flex: 1 }}>
                   <Text style={styles.providerCalendarTime}>{startLabel}</Text>
                   <Text
                     style={[
                       styles.providerCalendarService,
                       completed && styles.providerCalendarTextCompleted,
                     ]}
                   >
                     {booking?.service_name || "Service"}
                   </Text>
                   <Text
                     style={[
                       styles.providerCalendarCustomer,
                       completed && styles.providerCalendarTextCompleted,
                     ]}
                   >
                     {booking?.customer_name || "Customer"}
                   </Text>
                 </View>
-                <View
-                  style={[
-                    styles.providerCalendarStatusBadge,
-                    status.type === "cancelled" && styles.providerCalendarStatusBadgeCancelled,
-                    status.type === "completed" && styles.providerCalendarStatusBadgeCompleted,
-                  ]}
-                >
-                  <Text
+                <View style={styles.providerCalendarRightActions}>
+                  <View
                     style={[
-                      styles.providerCalendarStatusText,
-                      status.type === "cancelled" && styles.providerCalendarStatusTextCancelled,
-                      status.type === "completed" && styles.providerCalendarStatusTextCompleted,
+                      styles.providerCalendarStatusBadge,
+                      status.type === "cancelled" && styles.providerCalendarStatusBadgeCancelled,
+                      status.type === "completed" && styles.providerCalendarStatusBadgeCompleted,
                     ]}
-                    numberOfLines={1}
                   >
-                    {status.label}
-                  </Text>
+                    <Text
+                      style={[
+                        styles.providerCalendarStatusText,
+                        status.type === "cancelled" && styles.providerCalendarStatusTextCancelled,
+                        status.type === "completed" && styles.providerCalendarStatusTextCompleted,
+                      ]}
+                      numberOfLines={1}
+                    >
+                      {status.label}
+                    </Text>
+                  </View>
+                  {canCancel ? (
+                    <TouchableOpacity
+                      style={[
+                        styles.providerCalendarCancelButton,
+                        isCancelling && styles.providerCalendarCancelButtonDisabled,
+                      ]}
+                      onPress={() => handleCancelAppointment(booking)}
+                      disabled={isCancelling}
+                    >
+                      {isCancelling ? (
+                        <View style={styles.providerCalendarCancelButtonLoadingRow}>
+                          <ActivityIndicator size="small" color={colors.error} />
+                          <Text style={styles.providerCalendarCancelButtonText}>Cancellingâ€¦</Text>
+                        </View>
+                      ) : (
+                        <Text style={styles.providerCalendarCancelButtonText}>Cancel</Text>
+                      )}
+                    </TouchableOpacity>
+                  ) : null}
                 </View>
               </View>
             );
           }}
           ListHeaderComponent={
             <View style={{ backgroundColor: colors.background }}>
               <View style={styles.providerCalendarModeSwitch}>
                 {[
                   { key: "day", label: "Daily" },
                   { key: "week", label: "Weekly" },
                   { key: "month", label: "Monthly" },
                 ].map((mode) => {
                   const active = mode.key === viewMode;
                   return (
                     <TouchableOpacity
                       key={mode.key}
                       style={[
                         styles.providerCalendarModeButton,
                         active && styles.providerCalendarModeButtonActive,
                       ]}
                       onPress={() => setViewMode(mode.key)}
                     >
                       <Text
                         style={[
                           styles.providerCalendarModeText,
@@ -10437,29 +10549,54 @@ signupTextButtonText: {
   providerCalendarStatusBadge: {
     paddingHorizontal: 10,
     paddingVertical: 5,
     borderRadius: 999,
     borderWidth: 1,
     borderColor: colors.textSecondary,
     backgroundColor: colors.surfaceElevated,
   },
   providerCalendarStatusBadgeCancelled: {
     borderColor: colors.error,
   },
   providerCalendarStatusBadgeCompleted: {
     borderColor: colors.success,
   },
   providerCalendarStatusText: {
     color: colors.textSecondary,
     fontSize: 11,
     fontWeight: "700",
   },
   providerCalendarStatusTextCancelled: {
     color: colors.error,
   },
   providerCalendarStatusTextCompleted: {
     color: colors.success,
   },
+  providerCalendarRightActions: {
+    alignItems: "flex-end",
+  },
+  providerCalendarCancelButton: {
+    marginTop: 6,
+    paddingHorizontal: 10,
+    paddingVertical: 6,
+    borderRadius: 999,
+    borderWidth: 1,
+    borderColor: colors.error,
+    backgroundColor: "rgba(255,107,107,0.10)",
+  },
+  providerCalendarCancelButtonDisabled: {
+    opacity: 0.7,
+  },
+  providerCalendarCancelButtonLoadingRow: {
+    flexDirection: "row",
+    alignItems: "center",
+    gap: 6,
+  },
+  providerCalendarCancelButtonText: {
+    color: colors.error,
+    fontSize: 11,
+    fontWeight: "700",
+  },
 
 })
 
 export default App;
 
EOF
)