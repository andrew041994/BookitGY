 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 0981a7b7142c9c5925202d3d5cbd072696862d82..739d3be245c6447fd8bad363d356c004b6f5dcd3 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -11,229 +11,99 @@ import {
   ScrollView,
   TouchableOpacity,
   Switch,
   Linking,
   Platform,
   Image,
   KeyboardAvoidingView,
   TouchableWithoutFeedback,
   Keyboard,
   Pressable,
   RefreshControl,
   Share,
   Modal,
   FlatList,
 } from "react-native";
 import * as ExpoLinking from "expo-linking";
 
 import {
   NavigationContainer,
   CommonActions,
   useFocusEffect,
   useIsFocused,
 } from "@react-navigation/native";
 import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
 import { enableScreens } from "react-native-screens";
-import axios from "axios";
 import AsyncStorage from "@react-native-async-storage/async-storage";
 import {
-  clearToken,
   clearAllAuthTokens,
-  loadRefreshToken,
   loadToken,
   saveRefreshToken,
   saveToken,
 } from "./src/components/tokenStorage";
 import ProviderCard from "./src/components/ProviderCard";
 import * as Location from "expo-location";
 import Constants from "expo-constants";
 import * as ImagePicker from "expo-image-picker";
 import { Ionicons } from "@expo/vector-icons";
 import {
   CalendarProvider,
   Calendar,
 } from "react-native-calendars";
 import {
   SafeAreaProvider,
   SafeAreaView,
   useSafeAreaInsets,
 } from "react-native-safe-area-context";
-import { apiClient } from "./src/api"; 
+import { apiClient } from "./src/api";
 // import { AccessToken, LoginManager } from "react-native-fbsdk-next";
 import BookitGYLogoTransparent from "./assets/bookitgy-logo-transparent.png"
 import { theme } from "./src/theme";
 // import * as Sentry from "sentry-expo";
 
 let Clipboard = null;
 try {
   Clipboard = require("expo-clipboard");
 } catch (e) {}
 
 enableScreens(false);
 
 
 
 
 // import { API } from "./App"; // wherever you define your base URL
 
 
 
 
 
 const API =
   Constants.expoConfig?.extra?.API_URL ||
   Constants.manifest?.extra?.API_URL ||
   "https://bookitgy.onrender.com";
 
-// const api = axios.create({ baseURL: API });
-// const refreshApi = axios.create({ baseURL: API });
-
-// let accessTokenInMemory = null;
-// let refreshPromise = null;
-// let onApiUnauthorized = null;
-
-// const setApiUnauthorizedHandler = (handler) => {
-//   onApiUnauthorized = handler;
-// };
-
-// const setApiAccessToken = (accessToken) => {
-//   accessTokenInMemory = accessToken || null;
-
-//   if (accessToken) {
-//     api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
-//     return;
-//   }
-
-//   delete api.defaults.headers.common.Authorization;
-// };
-
-// const loadAccessTokenForRequest = async () => {
-//   if (accessTokenInMemory) return accessTokenInMemory;
-
-//   const storedToken = await loadToken();
-//   if (storedToken) {
-//     setApiAccessToken(storedToken);
-//     return storedToken;
-//   }
-
-//   const legacyToken = await AsyncStorage.getItem("accessToken");
-//   if (legacyToken) {
-//     setApiAccessToken(legacyToken);
-//     return legacyToken;
-//   }
-
-//   setApiAccessToken(null);
-//   return null;
-// };
-
-// const refreshAccessToken = async () => {
-//   const storedRefreshToken = await loadRefreshToken();
-//   if (!storedRefreshToken) {
-//     const missingRefreshError = new Error("Missing refresh token");
-//     missingRefreshError.code = "SESSION_EXPIRED";
-//     throw missingRefreshError;
-//   }
-
-//   const response = await refreshApi.post("/auth/refresh", {
-//     refresh_token: storedRefreshToken,
-//   });
-
-//   const newAccessToken = response?.data?.access_token;
-//   const newRefreshToken = response?.data?.refresh_token || storedRefreshToken;
-
-//   if (!newAccessToken) {
-//     const invalidRefreshError = new Error("Invalid refresh response");
-//     invalidRefreshError.code = "SESSION_EXPIRED";
-//     throw invalidRefreshError;
-//   }
-
-//   await saveToken(newAccessToken);
-//   await saveRefreshToken(newRefreshToken);
-//   setApiAccessToken(newAccessToken);
-//   return newAccessToken;
-// };
-
-// api.interceptors.request.use(async (config) => {
-//   const latestToken = await loadAccessTokenForRequest();
-
-//   if (latestToken) {
-//     config.headers = {
-//       ...(config.headers || {}),
-//       Authorization: `Bearer ${latestToken}`,
-//     };
-//   } else if (config.headers?.Authorization) {
-//     delete config.headers.Authorization;
-//   }
-
-//   return config;
-// });
-
-// api.interceptors.response.use(
-//   (response) => response,
-//   async (error) => {
-//     const originalRequest = error?.config || {};
-//     const status = error?.response?.status;
-//     const requestUrl = originalRequest?.url || "";
-
-//     if (
-//       status !== 401 ||
-//       originalRequest.__isRetryRequest ||
-//       requestUrl.includes("/auth/refresh")
-//     ) {
-//       return Promise.reject(error);
-//     }
-
-//     originalRequest.__isRetryRequest = true;
-
-//     try {
-//       if (!refreshPromise) {
-//         refreshPromise = refreshAccessToken().finally(() => {
-//           refreshPromise = null;
-//         });
-//       }
-
-//       const nextAccessToken = await refreshPromise;
-//       originalRequest.headers = {
-//         ...(originalRequest.headers || {}),
-//         Authorization: `Bearer ${nextAccessToken}`,
-//       };
-
-//       return api(originalRequest);
-//     } catch (refreshError) {
-//       setApiAccessToken(null);
-//       await clearAllAuthTokens();
-//       await AsyncStorage.removeItem("accessToken");
-//       if (typeof onApiUnauthorized === "function") {
-//         await onApiUnauthorized(refreshError);
-//       }
-//       refreshError.isAuthFailure = true;
-//       return Promise.reject(refreshError);
-//     }
-//   }
-// );
-
-  console.log("### API base URL =", API);
+console.log("### API base URL =", API);
 
 
 const colors = theme.colors;
 const HEADER_LOGO_WIDTH = 120;
 const HEADER_LOGO_HEIGHT = 120;
 const HEADER_VERTICAL_PADDING = 0;
 
 // status color mapping
 const getAppointmentStatusThemeKey = (statusValue) => {
   const normalized = `${statusValue || ""}`.trim().toLowerCase();
   if (normalized.includes("cancel")) return "cancelled";
   if (normalized.includes("complete")) return "completed";
   return "scheduled";
 };
 
 const APPOINTMENT_STATUS_THEME = {
   scheduled: {
     accent: "#4DA3FF",
     bgTint: "rgba(77,163,255,0.10)",
     border: "rgba(77,163,255,0.35)",
   },
   completed: {
     accent: "#2ECC71",
     bgTint: "rgba(46,204,113,0.10)",
     border: "rgba(46,204,113,0.35)",
@@ -267,51 +137,50 @@ const FB_COMPLETE_ERROR_MESSAGES = {
   EMAIL_REQUIRED: "Please provide an email address to continue.",
   PHONE_REQUIRED: "Please provide your phone number to continue.",
   PHONE_TAKEN: "This phone number is already in use.",
   FB_TOKEN_INVALID: "Facebook login session expired. Please try again.",
 };
 
 const normalizeErrorCode = (payload) => {
   if (!payload) return null;
   const detailCode = payload?.detail?.code;
   if (typeof detailCode === "string") return detailCode;
   if (typeof payload?.code === "string") return payload.code;
   if (typeof payload?.detail === "string") return payload.detail;
   return null;
 };
 
 const getFacebookCompleteErrorMessage = (code) =>
   FB_COMPLETE_ERROR_MESSAGES[code] || "Unable to complete Facebook login. Please try again.";
 
 const persistFacebookSession = async ({
   responseData,
   setToken,
   setIsAdmin,
 }) => {
   await saveToken(responseData.access_token);
   await saveRefreshToken(responseData.refresh_token);
-  setApiAccessToken(responseData.access_token);
 
   let meData = null;
   try {
     const meRes = await apiClient.get(`/users/me`);
     meData = meRes.data;
   } catch (meError) {
     console.log("[auth] Failed to fetch /users/me after Facebook login", meError?.message || meError);
   }
 
   setToken({
     token: responseData.access_token,
     userId: meData?.id || meData?.user_id || responseData.user_id,
     email: meData?.email || responseData.email,
     username: meData?.username,
     isProvider:
       typeof meData?.is_provider === "boolean"
         ? meData?.is_provider
         : responseData.is_provider,
     isAdmin:
       typeof meData?.is_admin === "boolean" ? meData?.is_admin : responseData.is_admin,
   });
 
   setIsAdmin(
     typeof meData?.is_admin === "boolean" ? meData?.is_admin : !!responseData.is_admin
   );
@@ -789,51 +658,50 @@ function LoginScreen({
     const normalizedEmail = trimmedEmail.toLowerCase();
 
     if (!trimmedEmail || !isValidEmail(trimmedEmail)) {
       if (showFlash) {
         showFlash("error", "Please enter a valid email address");
       } else {
         Alert.alert("Error", "Please enter a valid email address");
       }
       return;
   }
 
   setLoading(true);
 
     try {
       const body = new URLSearchParams({
         username: normalizedEmail,
         password: password,
       }).toString();
 
     const res = await apiClient.post(`/auth/login`, body, {
         headers: {
           "Content-Type": "application/x-www-form-urlencoded",
         },
       });
 
-    // setApiAccessToken(res.data.access_token);
 
     try {
       await saveToken(res.data.access_token);
       await saveRefreshToken(res.data.refresh_token);
       const persistedToken = await loadToken();
       console.log("[auth] login success -> token saved:", Boolean(persistedToken));
       if (!persistedToken) {
         Alert.alert(
           "Save issue",
           "We couldn't save your login securely. You'll stay logged in for now."
         );
       }
     } catch (err) {
       console.error(
         "[LOGIN_NATIVE_CRASH_GUARD] Failed to persist access token",
         err
       );
       // Sentry.Native.captureException(err, {
       //   extra: { scope: "token-persistence" },
       // });
       Alert.alert(
         "Save issue",
         "We couldn't save your login securely. You'll stay logged in for now."
       );
     }
@@ -1872,51 +1740,50 @@ function ProfileScreen({ authLoading, setToken, showFlash, token }) {
 
 
   const logout = async () => {
     try {
         await clearAllAuthTokens(); // âœ… clears access + refresh
       
         // Optional cleanup (keeps old installs from reviving stale tokens)
         try {
           await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
         } catch (e) {
           console.log("Error clearing legacy token", e?.message || e);
         }
       
         if (setToken) setToken(null);
       
         if (showFlash) showFlash("success", "Logged out successfully");
       } catch (err) {
         console.error("Error during logout", err);
         if (showFlash) showFlash("error", "Could not log out. Please try again.");
       }
     };
 
 
   // const logout = async () => {
   //   try {
-  //     await clearToken();
   //     if (setToken) {
   //       setToken(null);
   //     }
   //     if (showFlash) {
   //       showFlash("success", "Logged out successfully");
   //     }
   //   } catch (err) {
   //     console.error("Error during logout", err);
   //     if (showFlash) {
   //       showFlash("error", "Could not log out. Please try again.");
   //     }
   //   }
   // };
 
   const handleDeleteAccountRequest = () => {
     Alert.alert(
       "Delete account?",
       "This will delete your account and remove all personal data associated with it. Your appointments and billing history may be retained for record-keeping. This action cannot be undone.",
       [
         { text: "Cancel", style: "cancel" },
         {
           text: "Continue",
           style: "destructive",
           onPress: () => {
             setDeletePassword("");
@@ -5385,51 +5252,51 @@ const to24Hour = (time12) => {
     setAdding(false);
 
     // Optional: background refresh to stay in sync with backend
     loadServices();
   } catch (err) {
     console.log("Error creating service", err.response?.data || err.message);
     if (showFlash) {
       const detail =
         err.response?.data?.detail || "Could not create service.";
       showFlash("error", detail);
     }
   } finally {
     setIsSavingService(false);
   }
 };
 
 
   const handleDeleteService = async (serviceId) => {
     try {
       const authToken = await getAuthToken(token);
       if (!authToken) {
         if (showFlash) showFlash("error", "No access token found.");
         return;
       }
 
-      const res = await api.delete(`/providers/me/services/${serviceId}`);
+      const res = await apiClient.delete(`/providers/me/services/${serviceId}`);
 
       const responseData = res?.data || {};
       const responseStatus = `${responseData.status || responseData.result || ""}`.toLowerCase();
       const responseMessage =
         responseData.detail || responseData.message || responseData.error || "";
       const responseText = `${responseStatus} ${responseMessage}`.toLowerCase();
       const hasBookings = responseText.includes("booking");
 
       if (showFlash) {
         if (hasBookings) {
           showFlash(
             "info",
             "This service has bookings and was archived instead."
           );
         } else {
           showFlash("success", "Service removed from your list.");
         }
       }
 
       await loadServices();
     } catch (err) {
       console.log("Error deleting service", err.response?.data || err.message);
       const status = err.response?.status;
       const detail =
         err.response?.data?.detail ||
@@ -5610,51 +5477,51 @@ const pickCatalogImage = async () => {
     await uploadCatalogImage(asset.uri);
   } catch (err) {
     console.log("Error picking catalog image", err);
     alert("Could not open your gallery. Please try again.");
   }
 };
 
 
 const handleDeleteCatalogImage = (imageId) => {
   Alert.alert(
     "Remove photo",
     "Do you want to remove this photo from your catalog?",
     [
       { text: "Cancel", style: "cancel" },
       {
         text: "Remove",
         style: "destructive",
         onPress: async () => {
           try {
             const authToken = await getAuthToken(token);
             if (!authToken) {
               alert("No access token found. Please log in again.");
               return;
             }
 
-            await api.delete(`/providers/me/catalog/${imageId}`);
+            await apiClient.delete(`/providers/me/catalog/${imageId}`);
 
             setCatalog((prev) =>
               (prev || []).filter((img) => img.id !== imageId)
             );
 
             if (showFlash) {
               showFlash("success", "Photo removed from your catalog");
             }
           } catch (err) {
             console.log(
               "Error deleting catalog image",
               err.response?.data || err.message
             );
             const detail =
               err.response?.data?.detail ||
               "Could not remove photo. Please try again.";
             if (showFlash) showFlash("error", detail);
           }
         },
       },
     ]
   );
 };
 
 
@@ -8195,74 +8062,72 @@ function MainApp({
               if (focused) {
                 iconName = iconName.replace("-outline", "");
               }
 
               return (
                 <View
                   style={{
                     padding: 6,
                     borderRadius: 16,
                     backgroundColor: focused ? colors.primarySoft : "transparent",
                   }}
                 >
                   <Ionicons
                     name={iconName}
                     size={focused ? 26 : 22}
                     color={color}
                   />
                 </View>
               );
             },
           })}
         >
           <Tab.Screen name="Dashboard">
             {() => (
               <ProviderDashboardScreen
-                // apiClient={apiClient}
                 token={token}
                 showFlash={showFlash}
               />
             )}
           </Tab.Screen>
 
           <Tab.Screen name="Calendar">
             {() => (
               <ProviderCalendarScreen token={token} showFlash={showFlash} />
             )}
           </Tab.Screen>
 
           <Tab.Screen name="Billing">
             {() => (
               <ProviderBillingScreen token={token} showFlash={showFlash} />
             )}
           </Tab.Screen>
 
 
           <Tab.Screen name="Profile">
             {() => (
               <ProfileScreen
-                // apiClient={apiClient}
                 authLoading={authLoading}
                 token={token}
                 setToken={setToken}
                 showFlash={showFlash}
               />
             )}
           </Tab.Screen>
         </Tab.Navigator>
       ) : (
         // ðŸ‘‡ Client view: Profile + Search
             <Tab.Navigator
             screenOptions={({ route }) => ({
               headerShown: false,
               tabBarShowLabel: true,
               tabBarActiveTintColor: colors.primary,
               tabBarInactiveTintColor: colors.textSecondary,
               tabBarStyle: {
                 backgroundColor: colors.surface,
                 height: 76,
                 paddingBottom: Platform.OS === "ios" ? 24 : 12,
                 paddingTop: 8,
                 borderTopWidth: 1,
                 borderTopColor: colors.border,
                 shadowColor: "#000",
                 shadowOpacity: 0.08,
@@ -8324,51 +8189,50 @@ function MainApp({
                   isFavorite={isFavorite}
                   syncFavoritesFromList={syncFavoritesFromList}
                   refreshFavoriteProviders={refreshFavoriteProviders}
                 />
               )}
             </Tab.Screen>
             <Tab.Screen name="Search">
               {({ navigation, route }) => (
                 <SearchScreen
                   token={token}
                   showFlash={showFlash}
                   navigation={navigation}
                   route={route}
                   toggleFavorite={toggleFavorite}
                   isFavorite={isFavorite}
                   syncFavoritesFromList={syncFavoritesFromList}
                 />
               )}
             </Tab.Screen>
             <Tab.Screen name="Appointments">
               {() => <AppointmentsScreen token={token} showFlash={showFlash} />}
             </Tab.Screen>
             <Tab.Screen name="Profile">
               {() => (
                 <ProfileScreen
-                  // apiClient={apiClient}
                   authLoading={authLoading}
                   token={token}
                   setToken={setToken}
                   showFlash={showFlash}
                 />
               )}
             </Tab.Screen>
           </Tab.Navigator>
 
 
       )}
     </NavigationContainer>
   );
 }
 
 
 
 
 //Flash message component
 
 function FlashMessage({ flash }) {
   if (!flash || !flash.text) return null;
 
   const isError = flash.type === "error";
 
@@ -8396,146 +8260,96 @@ function FlashMessage({ flash }) {
 
 const DEEPLINK_DEBUG = false;
 
 function App() {
 
   const mountIdRef = useRef(Math.random().toString(16).slice(2));
   console.log("APP MOUNT ID:", mountIdRef.current);
   useEffect(() => console.log("APP useEffect ran for mount", mountIdRef.current), []);
 
   const [token, setToken] = useState(null);
   const [authLoading, setAuthLoading] = useState(true);
   const [authMode, setAuthMode] = useState("landing"); // 'landing' | 'login' | 'signup' | 'forgot' | 'finishSetup'
   const [isAdmin, setIsAdmin] = useState(false);
   const [facebookSetup, setFacebookSetup] = useState(null);
   const [pendingDeepLinkUsername, setPendingDeepLinkUsername] = useState(null);
   const [navReady, setNavReady] = useState(false);
   const navReadyRef = useRef(false);
   const navigationRef = useRef(null);
   const authBootstrapRef = useRef({ inFlight: false, completed: false });
   const tokenRef = useRef(token);
   const lastDeeplinkHandledAtRef = useRef(0);
   const lastHandledUrlRef = useRef(null);
   const url = ExpoLinking.useURL();
 
   const [flash, setFlash] = useState(null);
-  // const apiClient = api;
-
-  const handleUnauthorized = useCallback(async () => {
-     setApiAccessToken(null);
-     try {
-       await clearAllAuthTokens(); // âœ… clears access + refresh (and your new fallbacks)
-     } catch (storageError) {
-       console.log(
-         "[auth] Failed to clear all auth tokens",
-         storageError?.message || storageError
-       );
-     }
-
-     try {
-       await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY); // optional, but fine
-     } catch (storageError) {
-       console.log(
-         "[auth] Failed to clear legacy token",
-         storageError?.message || storageError
-       );
-     }
-
-     setToken(null);
-    }, []);
-
-
-  // const handleUnauthorized = useCallback(async () => {
-  //   try {
-  //     await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
-  //   } catch (storageError) {
-  //     console.log(
-  //       "[auth] Failed to clear legacy token",
-  //       storageError?.message || storageError
-  //     );
-  //   }
-  //   setToken(null);
-  // }, []);
-
-  // useEffect(() => {
-  //   setApiUnauthorizedHandler(handleUnauthorized);
-  //   return () => {
-  //     setApiUnauthorizedHandler(null);
-  //   };
-  // }, [handleUnauthorized]);
-
-
 
   const formatFlashText = useCallback((text) => {
     if (typeof text === "string") return text;
     if (text == null) return "Something went wrong.";
 
     const formatErrorItem = (item) => {
       if (typeof item === "string") return item;
       if (!item || typeof item !== "object") return String(item);
 
       const message = item.msg || item.message;
       if (Array.isArray(item.loc) && item.loc.length > 0) {
         const field = item.loc[item.loc.length - 1];
         return message ? `${field}: ${message}` : String(item);
       }
       if (message) return message;
       return JSON.stringify(item);
     };
 
     if (Array.isArray(text)) {
       return text.map(formatErrorItem).filter(Boolean).join("\n");
     }
 
     if (typeof text === "object") {
       if (Array.isArray(text.detail)) {
         return formatFlashText(text.detail);
       }
       if (typeof text.detail === "string") return text.detail;
       if (typeof text.message === "string") return text.message;
       if (typeof text.msg === "string") return text.msg;
       return JSON.stringify(text);
     }
 
     return String(text);
   }, []);
 
   const showFlash = useCallback((type, text) => {
     setFlash({ type, text: formatFlashText(text) });
     setTimeout(() => {
       setFlash(null);
     }, 4500);
   }, [formatFlashText]);
 
   useEffect(() => {
     tokenRef.current = token;
   }, [token]);
 
-  // useEffect(() => {
-  //   setApiAccessToken(token?.token || null);
-  // }, [token?.token]);
-
   useEffect(() => {
     navReadyRef.current = navReady;
   }, [navReady]);
 
   useEffect(() => {
     if (!token) setNavReady(false);
   }, [token]);
 
   const navigateToClientSearch = useCallback(
   (username, navRef, nonce) => {
     if (!navRef?.current) return false;
 
     const params = { incomingUsername: username, deeplinkNonce: nonce };
 
     navRef.current.navigate({
       name: "Search",
       params,
       merge: false,
     });
 
     return true;
   },
   []
 );
 
@@ -8636,51 +8450,50 @@ function App() {
       ok
     );
     if (ok) setPendingDeepLinkUsername(null);
   }, [pendingDeepLinkUsername, token, navReady, showFlash]);
 
   useEffect(() => {
     let isActive = true;
     const restoreSession = async () => {
       if (authBootstrapRef.current.inFlight || authBootstrapRef.current.completed) {
         return;
       }
       authBootstrapRef.current.inFlight = true;
       const bootstrapStartedAt = Date.now();
       console.log("[auth] bootstrap start");
       try {
         const restoredToken = await withTimeout(
           getAuthToken(),
           AUTH_TOKEN_TIMEOUT_MS,
           "getAuthToken"
         );
         console.log("[auth] token loaded:", Boolean(restoredToken));
 
         if (!restoredToken) {
           if (isActive) setToken(null);
         } else {
-          setApiAccessToken(restoredToken);
           try {
             const meRes = await withTimeout(
               apiClient.get("/users/me", {
                 timeout: AUTH_ME_TIMEOUT_MS,
               }),
               AUTH_ME_TIMEOUT_MS,
               "/users/me"
             );
             console.log("[auth] /users/me success", meRes?.status);
             const latestToken = await getAuthToken();
             if (isActive) {
               setToken({
                 token: latestToken || restoredToken,
                 userId: meRes.data?.id || meRes.data?.user_id,
                 email: meRes.data?.email,
                 username: meRes.data?.username,
                 isProvider: Boolean(meRes.data?.is_provider),
                 isAdmin: Boolean(meRes.data?.is_admin),
               });
               setIsAdmin(Boolean(meRes.data?.is_admin));
             }
           } catch (err) {
             console.log(
               "[auth] Failed to load user info during bootstrap",
               err?.message || err
@@ -8720,51 +8533,51 @@ function App() {
         }
       } catch (err) {
         console.log(
           "[auth] Failed to restore session",
           err?.message || err
         );
         if (isActive) setToken(null);
       } finally {
         authBootstrapRef.current.inFlight = false;
         authBootstrapRef.current.completed = true;
         if (isActive) {
           setAuthLoading(false);
           console.log(
             "[auth] bootstrap end",
             `${Date.now() - bootstrapStartedAt}ms`
           );
         }
       }
     };
 
     restoreSession();
 
     return () => {
       isActive = false;
     };
-  }, [apiClient]);
+  }, []);
 
   useEffect(() => {
     if (!authLoading) return undefined;
 
     const watchdog = setTimeout(() => {
       if (authLoading) {
         console.log("[auth] authLoading watchdog timeout");
         setAuthLoading(false);
       }
     }, AUTH_BOOTSTRAP_WATCHDOG_MS);
 
     return () => clearTimeout(watchdog);
   }, [authLoading]);
 
   useEffect(() => {
     console.log("[auth] authLoading:", authLoading);
   }, [authLoading]);
 
   if (authLoading) {
 
     return (
       <SafeAreaProvider>
         <SafeAreaView style={{ flex: 1, backgroundColor: colors.background }} edges={["top", "bottom"]}>
           <FlashMessage flash={flash} />
           <View style={styles.center}>
@@ -8819,51 +8632,50 @@ function App() {
               />
             )}
             {authMode === "forgot" && (
               <ForgotPasswordScreen
                 goToLogin={() => setAuthMode("login")}
                 goBack={() => setAuthMode("landing")}
                 showFlash={showFlash}
               />
             )}
 
             {authMode === "finishSetup" && (
               <FinishSetupScreen
                 facebookSetup={facebookSetup}
                 setToken={setToken}
                 setIsAdmin={setIsAdmin}
                 goBackToLogin={() => {
                   setFacebookSetup(null);
                   setAuthMode("login");
                 }}
                 showFlash={showFlash}
               />
             )}
           </>
         ) : (
           <MainApp
-            apiClient={apiClient}
             authLoading={authLoading}
             token={token}
             setToken={setToken}
             showFlash={showFlash}
             navigationRef={navigationRef}
             setNavReady={setNavReady}
           />
         )}
       </SafeAreaView>
     </SafeAreaProvider>
   );
 }
 
 
 
 
 const styles = StyleSheet.create({
   container: {
     flex: 1,
     backgroundColor: colors.background,
     justifyContent: "center",
     alignItems: "center",
     padding: 20,
   },
   title: {
 
EOF
)