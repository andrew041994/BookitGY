 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/crud.py b/backend/app/crud.py
index c81b87c4abe85497010fd3ec14e2d7a6d53081af..e02bacd0295ac6d92a3da1fb447e500c48d2105b 100644
--- a/backend/app/crud.py
+++ b/backend/app/crud.py
@@ -899,136 +899,149 @@ def _calculate_bill_total_due(db: Session, bill: models.Bill, provider_id: int)
     """Mirror the provider-facing bill "Total due" for a given bill."""
 
     total_due = Decimal(str(bill.fee_gyd or 0)).quantize(
         Decimal("1"), rounding=ROUND_HALF_UP
     )
     credits = Decimal(str(get_provider_credit_balance(db, provider_id) or 0))
     # Bill credits should only ever reduce what a provider owes. If the balance is
     # negative (e.g., from a bad manual entry), clamp it to zero so we don't
     # accidentally inflate the amount due.
     credits = max(credits, Decimal("0"))
 
     net_due = (total_due - credits).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
     if net_due < 0:
         net_due = Decimal("0")
 
     return float(net_due)
 
 
 from datetime import date
 from decimal import Decimal
 
 from app.config import get_settings
 from app import models
 # get_provider_credit_balance should already be defined in this file
 
+CANCELLED_STATUSES = {"cancelled", "canceled"}
+
+
+def _is_cancelled_status(status: str | None) -> bool:
+    if not status:
+        return False
+
+    return status.strip().lower() in CANCELLED_STATUSES
+
 
 def _billable_bookings_base_query(
     db: Session, provider_id: int, as_of: datetime | None = None
 ):
     """Return a base query for bookings that are eligible for billing.
 
     Eligibility rules (applied consistently across billing calculations):
     - Booking is NOT cancelled.
     - Booking has ended.
     - Appointment end time is on or before the cutoff.
     """
 
     cutoff = as_of or datetime.utcnow()
 
 
     normalized_status = func.lower(
         func.trim(func.coalesce(cast(models.Booking.status, String), ""))
     )
 
 
     return (
         db.query(models.Booking, models.Service, models.User)
         .join(models.Service, models.Booking.service_id == models.Service.id)
         .join(models.Provider, models.Service.provider_id == models.Provider.id)
         .join(models.User, models.Booking.customer_id == models.User.id)
         .filter(
             models.Provider.id == provider_id,
-            normalized_status.notin_({"cancelled", "canceled"}),
+            normalized_status.notin_(CANCELLED_STATUSES),
             models.Booking.end_time.isnot(None),
             models.Booking.end_time <= cutoff,
         )
     )
 
 
 def _billing_period_bounds(reference: datetime) -> tuple[datetime, datetime]:
     """Return start/end datetimes covering the month containing ``reference``."""
 
     start = datetime(reference.year, reference.month, 1)
     if reference.month == 12:
         end = datetime(reference.year + 1, 1, 1)
     else:
         end = datetime(reference.year, reference.month + 1, 1)
 
     return start, end
 
 
 def get_provider_fees_due(db: Session, provider_id: int) -> float:
     """
     Compute the *current month's* amount due for this provider in GYD,
     using only completed (ended) and non-cancelled bookings.
 
     Logic:
     - Look at bookings that have ended (end_time <= now) and are not cancelled,
     - Take only those whose service date falls in the current calendar month,
     - Sum the service prices for those bookings,
     - Apply the platform service charge percentage,
     - Subtract bill credits (but never go below 0).
 
     This intentionally ignores the stored Bill rows and instead computes
     the amount due from live booking data so the admin dashboard matches
     what the provider sees.
     """
     now_utc = datetime.utcnow()
     period_start, period_end = _billing_period_bounds(now_utc)
 
     _auto_complete_finished_bookings(db, provider_id=provider_id, as_of=now_utc)
 
     rows = (
         _billable_bookings_base_query(db, provider_id, as_of=now_utc)
         .filter(
             models.Booking.end_time >= period_start,
             models.Booking.end_time < period_end,
         )
         .with_entities(
             models.Booking.end_time,
+            models.Booking.status,
             models.Service.price_gyd.label("service_price_gyd"),
         )
         .all()
     )
 
     services_total = Decimal("0")
     for r in rows:
         end_time = r.end_time
         if not end_time:
             continue
 
+        if _is_cancelled_status(r.status):
+            continue
+
         price = r.service_price_gyd or 0
         services_total += Decimal(str(price))
 
     if services_total <= 0:
         return 0.0
 
     service_charge_pct = get_platform_service_charge_percentage(db)
     fee_rate = Decimal(str(max(service_charge_pct, 0))) / Decimal("100")
 
     platform_fee = services_total * fee_rate
     platform_fee = platform_fee.quantize(Decimal("1"))
 
     if platform_fee <= 0:
         return 0.0
 
     credits = Decimal(str(get_provider_credit_balance(db, provider_id) or 0))
     applied_credits = min(credits, platform_fee)
     total_due = platform_fee - applied_credits
 
     if total_due < 0:
         total_due = Decimal("0")
 
     return float(total_due)
 
 
@@ -1038,58 +1051,62 @@ def get_provider_current_month_due_from_completed_bookings(
     db: Session, provider_id: int
 ) -> float:
     """
     Compute the provider's current-month amount due using only completed (ended)
     and non-cancelled bookings.
 
     This is intentionally aligned with the provider-facing billing screen logic:
     - Uses the same billable-bookings semantics as provider invoices,
     - Filters those bookings to the current calendar month,
     - Applies the platform service charge percentage,
     - Applies available bill credits, but never returns a negative value.
     """
     now = datetime.utcnow()
     period_start, period_end = _billing_period_bounds(now)
 
     _auto_complete_finished_bookings(db, provider_id=provider_id, as_of=now)
 
     rows = (
         _billable_bookings_base_query(db, provider_id, as_of=now)
         .filter(
             models.Booking.end_time >= period_start,
             models.Booking.end_time < period_end,
         )
         .with_entities(
             models.Booking.end_time,
+            models.Booking.status,
             models.Service.price_gyd.label("service_price_gyd"),
         )
         .order_by(models.Booking.end_time.asc())
         .all()
     )
 
     services_total = Decimal("0")
     for r in rows:
+        if _is_cancelled_status(r.status):
+            continue
+
         price = r.service_price_gyd or 0
         services_total += Decimal(str(price))
 
     if services_total <= 0:
         return 0.0
 
     service_charge_pct = get_platform_service_charge_percentage(db)
     fee_rate = Decimal(str(max(service_charge_pct, 0))) / Decimal("100")
     platform_fee = services_total * fee_rate
 
     platform_fee = platform_fee.quantize(Decimal("1"))
     if platform_fee <= 0:
         return 0.0
 
     credits = Decimal(str(get_provider_credit_balance(db, provider_id) or 0))
     applied_credits = min(credits, platform_fee)
     total_due = platform_fee - applied_credits
 
     if total_due < 0:
         total_due = Decimal("0")
 
     return float(total_due)
 
 
 
@@ -1225,63 +1242,70 @@ def get_billable_bookings_for_provider(
     default_start, default_end = _billing_period_bounds(cutoff)
 
     period_start = period_start or default_start
     period_end = period_end or default_end
     _auto_complete_finished_bookings(db, provider_id=provider_id, as_of=cutoff)
 
     rows = (
         _billable_bookings_base_query(db, provider_id, as_of=cutoff)
         .filter(
             models.Booking.end_time >= period_start,
             models.Booking.end_time < period_end,
         )
         .with_entities(
             models.Booking.id,
             models.Booking.start_time,
             models.Booking.end_time,
             models.Booking.status,
             models.Service.name.label("service_name"),
             models.Service.price_gyd.label("service_price_gyd"),
             models.User.username.label("customer_name"),
         )
         .order_by(models.Booking.end_time.desc())
         .all()
     )
 
-    return [
-        {
-            "id": r.id,
-            "service_name": r.service_name,
-            "service_price_gyd": float(r.service_price_gyd or 0.0),
-            "customer_name": r.customer_name,
-            "start_time": r.start_time,
-            "end_time": r.end_time,
-            "status": r.status,
-            "completed_at": None,
-        }
-        for r in rows
-    ]
+    billable_rows = []
+
+    for r in rows:
+        if _is_cancelled_status(r.status):
+            continue
+
+        billable_rows.append(
+            {
+                "id": r.id,
+                "service_name": r.service_name,
+                "service_price_gyd": float(r.service_price_gyd or 0.0),
+                "customer_name": r.customer_name,
+                "start_time": r.start_time,
+                "end_time": r.end_time,
+                "status": r.status,
+                "completed_at": None,
+            }
+        )
+
+    return billable_rows
 
 
 def list_billable_bookings_for_provider(
     db: Session,
     provider_id: int,
     period_start: datetime | None = None,
     period_end: datetime | None = None,
     as_of: datetime | None = None,
 ):
     """Deprecated alias for backwards compatibility."""
 
     return get_billable_bookings_for_provider(
         db,
         provider_id,
         period_start=period_start,
         period_end=period_end,
         as_of=as_of,
     )
 
 
 def _refresh_bill_for_booking(db: Session, booking: models.Booking) -> None:
     """Regenerate bills for the month containing this booking."""
 
     if not booking.start_time:
         return
 
EOF
)