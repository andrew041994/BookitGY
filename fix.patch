 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/crud.py b/backend/app/crud.py
index 0eb3aef99db4079d260df9516ef5105657f52965..a7dd5aa12d002217f56692764d0c2b8326fe16ee 100644
--- a/backend/app/crud.py
+++ b/backend/app/crud.py
@@ -1033,120 +1033,115 @@ def _auto_complete_finished_bookings(
 
     update_data = {models.Booking.status: "completed"}
     if "completed_at" in models.Booking.__table__.columns:
         update_data[models.Booking.completed_at] = cutoff
 
     updated = (
         db.query(models.Booking)
         .filter(models.Booking.id.in_(candidate_ids))
         .filter(models.Booking.end_time <= cutoff)
         .filter(normalized_status == "confirmed")
         .update(update_data, synchronize_session=False)
     )
 
     if updated:
         db.commit()
 
 
 def generate_monthly_bills(db: Session, month: date):
     """
     Generate or update bills for all providers for the given month.
 
     - Only counts bookings that are:
         * completed (booking has ended) and not cancelled
         * belong to this provider
         * have end_time inside [first_of_month, first_of_next_month)
-    - Safe to run multiple times (updates existing unpaid bill instead of duplicating).
+    - Safe to run multiple times (creates missing bills only).
     """
     providers = db.query(models.Provider).all()
 
     # First day of this month
     start = date(month.year, month.month, 1)
 
     # First day of the next month
     if month.month == 12:
         next_month = date(month.year + 1, 1, 1)
     else:
         next_month = date(month.year, month.month + 1, 1)
 
     start_dt = datetime(start.year, start.month, start.day)
     end_dt = datetime(next_month.year, next_month.month, next_month.day)
 
     now = now_guyana()
 
     # Don't count future appointments that haven't ended yet
     period_end = min(end_dt, now)
 
     for prov in providers:
         total = (
             _billable_bookings_base_query(db, prov.id, as_of=period_end)
             .with_entities(func.sum(models.Service.price_gyd))
             .filter(
                 models.Booking.end_time >= start_dt,
                 models.Booking.end_time < period_end,
             )
             .scalar()
             or 0
         )
 
         # Platform fee on completed bookings using admin-configured percentage
         service_charge_pct = get_platform_service_charge_percentage(db)
         fee_rate = service_charge_pct / Decimal("100")
         fee = fee_rate * Decimal(str(total))
 
-        # If there's nothing to bill and no existing bill, skip
         existing_bill = (
             db.query(models.Bill)
             .filter(
                 models.Bill.provider_id == prov.id,
                 models.Bill.month == start,
             )
             .first()
         )
-        if not existing_bill and total == 0:
+        if existing_bill:
+            continue
+
+        # If there's nothing to bill and no existing bill, skip
+        if total == 0:
             continue
 
         # Bill due on the 15th of the following month
         due = datetime(next_month.year, next_month.month, 15, 23, 59)
 
-        if existing_bill:
-            # Don't overwrite already-paid bills
-            if existing_bill.is_paid:
-                continue
-
-            existing_bill.total_gyd = total
-            existing_bill.fee_gyd = fee
-            existing_bill.due_date = due
-        else:
-            bill = models.Bill(
-                provider_id=prov.id,
-                month=start,
-                total_gyd=total,
-                fee_gyd=fee,
-                due_date=due,
-            )
-            db.add(bill)
+        bill = models.Bill(
+            provider_id=prov.id,
+            month=start,
+            total_gyd=total,
+            fee_gyd=fee,
+            due_date=due,
+            is_paid=False,
+        )
+        db.add(bill)
 
     db.commit()
 
 
 def list_bills_for_provider(db: Session, provider_id: int):
     """Return persisted monthly bills for a provider (newest first)."""
 
     return (
         db.query(models.Bill)
         .filter(models.Bill.provider_id == provider_id)
         .order_by(models.Bill.month.desc())
         .all()
     )
 
 
 def _calculate_bill_total_due(db: Session, bill: models.Bill, provider_id: int) -> float:
     """Mirror the provider-facing bill "Total due" for a given bill."""
 
     total_due = Decimal(str(bill.fee_gyd or 0)).quantize(
         Decimal("1"), rounding=ROUND_HALF_UP
     )
     credits = Decimal(str(get_provider_credit_balance(db, provider_id) or 0))
     # Bill credits should only ever reduce what a provider owes. If the balance is
     # negative (e.g., from a bad manual entry), clamp it to zero so we don't
     # accidentally inflate the amount due.
 
EOF
)