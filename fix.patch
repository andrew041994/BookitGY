 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index ebd4a55fe82bdb0c0f5a9af81cfd49f35f3838fd..bfafe257bb8c8c9ad33921752bb41430801113cd 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -94,50 +94,103 @@ const getAuthToken = async (tokenState) => {
     const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await withTimeout(
       AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY),
       1500,
       "loadLegacyToken"
     );
     return legacy || null;
   } catch (error) {
     console.log("[auth] Failed to load legacy token", error?.message || error);
     return null;
   }
 };
 
 const FAVORITES_STORAGE_KEY = (userKey) =>
   userKey ? `favoriteProviders:${userKey}` : "favoriteProviders";
 
 const getProviderId = (provider) =>
   provider?.provider_id ?? provider?.id ?? provider?._id ?? null;
 
+const RESERVED_USERNAME_PATHS = new Set([
+  "u",
+  "privacy",
+  "terms",
+  "download",
+  "login",
+  "signup",
+  "forgot",
+  "reset",
+]);
+
+function extractUsernameFromUrl(url) {
+  if (!url) return null;
+  const trimmed = String(url).trim();
+  if (!trimmed) return null;
+
+  const withoutQuery = trimmed.split(/[?#]/)[0];
+  let pathname = withoutQuery;
+
+  try {
+    const parsed = new URL(withoutQuery);
+    pathname = parsed.pathname || "";
+  } catch (error) {
+    const schemeMatch = withoutQuery.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\/(.*)$/);
+    if (schemeMatch?.[1]) {
+      pathname = `/${schemeMatch[1]}`;
+    }
+  }
+
+  const segments = pathname.split("/").filter(Boolean);
+  if (segments.length === 0) return null;
+
+  let username = null;
+
+  if (segments[0] === "u" && segments[1]) {
+    username = segments[1];
+  } else if (segments.length === 1 && !RESERVED_USERNAME_PATHS.has(segments[0])) {
+    username = segments[0];
+  }
+
+  if (!username) return null;
+
+  let decoded = username;
+  try {
+    decoded = decodeURIComponent(username);
+  } catch (error) {
+    decoded = username;
+  }
+
+  const cleaned = decoded.trim().replace(/^@/, "");
+  return cleaned || null;
+}
+
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
 
   const persistIds = useCallback(async (ids) => {
     try {
       await AsyncStorage.setItem(storageKey, JSON.stringify(ids));
     } catch (err) {
       console.log("Error saving favorites", err?.message || err);
     }
   }, [storageKey]);
 
   const loadFavoritesFromStorage = useCallback(async () => {
     try {
       setFavoritesLoading(true);
       const raw = await AsyncStorage.getItem(storageKey);
       const parsed = raw ? JSON.parse(raw) : [];
       setFavoriteIds(Array.isArray(parsed) ? parsed : []);
     } catch (err) {
       console.log("Error reading favorites", err?.message || err);
       setFavoriteIds([]);
     } finally {
       setFavoritesLoading(false);
@@ -2470,50 +2523,56 @@ function SearchScreen({
   const [radiusKm, setRadiusKm] = useState(0); // 0 = any distance
   const [clientLocation, setClientLocation] = useState(null);
   const [locationError, setLocationError] = useState("");
   const [providers, setProviders] = useState([]);
   const [providersLoading, setProvidersLoading] = useState(true);
   const [providersError, setProvidersError] = useState("");
   const [selectedProvider, setSelectedProvider] = useState(null);
   const [services, setServices] = useState([]);
   const [servicesLoading, setServicesLoading] = useState(false);
   const [servicesError, setServicesError] = useState("");
   const [selectedService, setSelectedService] = useState(null);
   const [catalogImages, setCatalogImages] = useState([]);
   const [catalogLoading, setCatalogLoading] = useState(false);
   const [catalogError, setCatalogError] = useState("");
   const [availability, setAvailability] = useState([]);
   const [availabilityLoading, setAvailabilityLoading] = useState(false);
   const [availabilityError, setAvailabilityError] = useState("");
   const [selectedDate, setSelectedDate] = useState(null);
   const [selectedSlot, setSelectedSlot] = useState(null); // ISO string
   const [bookingLoading, setBookingLoading] = useState(false);
   const [hasSearched, setHasSearched] = useState(false); // ðŸ‘ˆ NEW
   const [refreshing, setRefreshing] = useState(false);
   //Radius 
   const radiusOptions = [0, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100];
 
+  useEffect(() => {
+    if (!incomingUsername) return;
+    setSearchQuery(incomingUsername);
+    setHasSearched(true);
+  }, [incomingUsername]);
+
   const haversineKm = (lat1, lon1, lat2, lon2) => {
     if (
       lat1 == null ||
       lon1 == null ||
       lat2 == null ||
       lon2 == null
     ) {
       return null;
     }
     const toRad = (v) => (v * Math.PI) / 180;
     const R = 6371; // km
     const dLat = toRad(lat2 - lat1);
     const dLon = toRad(lon2 - lon1);
     const a =
       Math.sin(dLat / 2) * Math.sin(dLat / 2) +
       Math.cos(toRad(lat1)) *
         Math.cos(toRad(lat2)) *
         Math.sin(dLon / 2) *
         Math.sin(dLon / 2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
     return R * c;
   };
 
 
   const handleSearchSubmit = () => {
@@ -2598,58 +2657,62 @@ function SearchScreen({
         (p) => getProviderId(p) === navProviderId
       );
 
       setFilteredProviders([exactMatch || providerFromNav]);
       return;
     }
 
     let list = providerList.map((p) => {
       let distance_km = null;
       if (clientLocation && p.lat != null && p.long != null) {
         distance_km = haversineKm(
           clientLocation.lat,
           clientLocation.long,
           p.lat,
           p.long
         );
       }
       return { ...p, distance_km };
     });
 
     // text filter (profession/name/location)
     if (q) {
       list = list.filter((p) => {
         const name = (p.name || "").toLowerCase();
         const location = (p.location || "").toLowerCase();
+        const username = (p.username || "").toLowerCase();
+        const username2 = (p.user?.username || "").toLowerCase();
         const professions = (p.professions || []).map((pr) =>
           (pr || "").toLowerCase()
         );
 
         return (
           professions.some((pr) => pr.includes(q)) ||
           name.includes(q) ||
-          location.includes(q)
+          location.includes(q) ||
+          username.includes(q) ||
+          username2.includes(q)
         );
       });
     }
 
     // distance filter
     if (radiusKm > 0) {
       if (!clientLocation) {
         setLocationError(
           "Turn on location services to filter providers by distance."
         );
       } else {
         setLocationError("");
         list = list.filter(
           (p) =>
             typeof p.distance_km === "number" &&
             p.distance_km <= radiusKm
         );
         list.sort((a, b) => {
           const da = a.distance_km ?? 999999;
           const db = b.distance_km ?? 999999;
           return da - db;
         });
       }
     } else {
       setLocationError("");
@@ -5712,50 +5775,51 @@ function FlashMessage({ flash }) {
       style={[
         styles.flashContainer,
         { backgroundColor, borderColor },
       ]}
     >
       <Text style={[styles.flashText, { color: textColor }]}>
         {flash.text}
       </Text>
     </View>
   );
 }
 
 
 // ðŸ”¹ App orchestrates landing/login/signup/forgot-password vs main app
 
 function App() {
 
   const mountIdRef = useRef(Math.random().toString(16).slice(2));
   console.log("APP MOUNT ID:", mountIdRef.current);
   useEffect(() => console.log("APP useEffect ran for mount", mountIdRef.current), []);
 
   const [token, setToken] = useState(null);
   const [authLoading, setAuthLoading] = useState(true);
   const [authMode, setAuthMode] = useState("landing"); // 'landing' | 'login' | 'signup' | 'forgot'
   const [isAdmin, setIsAdmin] = useState(false);
+  const [pendingDeepLinkUsername, setPendingDeepLinkUsername] = useState(null);
   const navigationRef = useRef(null);
   const authBootstrapRef = useRef({ inFlight: false, completed: false });
 
   const [flash, setFlash] = useState(null);
   const handleUnauthorized = useCallback(async () => {
     try {
       await AsyncStorage.removeItem(LEGACY_ACCESS_TOKEN_KEY);
     } catch (storageError) {
       console.log(
         "[auth] Failed to clear legacy token",
         storageError?.message || storageError
       );
     }
     setToken(null);
   }, []);
 
   const apiClient = useMemo(
     () =>
       createApiClient({
         baseURL: API,
         onUnauthorized: handleUnauthorized,
       }),
     [handleUnauthorized]
   );
 
@@ -5780,50 +5844,103 @@ function App() {
 
     if (Array.isArray(text)) {
       return text.map(formatErrorItem).filter(Boolean).join("\n");
     }
 
     if (typeof text === "object") {
       if (Array.isArray(text.detail)) {
         return formatFlashText(text.detail);
       }
       if (typeof text.detail === "string") return text.detail;
       if (typeof text.message === "string") return text.message;
       if (typeof text.msg === "string") return text.msg;
       return JSON.stringify(text);
     }
 
     return String(text);
   };
 
   const showFlash = (type, text) => {
     setFlash({ type, text: formatFlashText(text) });
     setTimeout(() => {
       setFlash(null);
     }, 4500);
   };
 
+  useEffect(() => {
+    let isActive = true;
+
+    Linking.getInitialURL().then((url) => {
+      if (!isActive) return;
+      const username = extractUsernameFromUrl(url);
+      console.log("[deeplink] initial url", url, "username", username);
+      if (username) {
+        setPendingDeepLinkUsername(username);
+      }
+    });
+
+    const sub = Linking.addEventListener("url", ({ url }) => {
+      const username = extractUsernameFromUrl(url);
+      console.log("[deeplink] url event", url, "username", username);
+      if (username) {
+        setPendingDeepLinkUsername(username);
+      }
+    });
+
+    return () => {
+      isActive = false;
+      sub.remove();
+    };
+  }, []);
+
+  useEffect(() => {
+    if (!pendingDeepLinkUsername || !token) return;
+
+    if (token.isProvider) {
+      console.log(
+        "[deeplink] provider user ignoring username",
+        pendingDeepLinkUsername
+      );
+      if (showFlash) {
+        showFlash("error", "Open as a client to view provider links.");
+      }
+      setPendingDeepLinkUsername(null);
+      return;
+    }
+
+    if (!navigationRef.current) return;
+
+    console.log(
+      "[deeplink] navigating to Search for",
+      pendingDeepLinkUsername
+    );
+    navigationRef.current.navigate("Search", {
+      incomingUsername: pendingDeepLinkUsername,
+    });
+    setPendingDeepLinkUsername(null);
+  }, [pendingDeepLinkUsername, token, showFlash]);
+
   useEffect(() => {
     let isActive = true;
     const restoreSession = async () => {
       if (authBootstrapRef.current.inFlight || authBootstrapRef.current.completed) {
         return;
       }
       authBootstrapRef.current.inFlight = true;
       const bootstrapStartedAt = Date.now();
       console.log("[auth] bootstrap start");
       try {
         const restoredToken = await withTimeout(
           getAuthToken(),
           AUTH_TOKEN_TIMEOUT_MS,
           "getAuthToken"
         );
         console.log("[auth] token loaded:", Boolean(restoredToken));
 
         if (!restoredToken) {
           if (isActive) setToken(null);
         } else {
           try {
             const meRes = await withTimeout(
               apiClient.get("/users/me", {
                 headers: {
                   Authorization: `Bearer ${restoredToken}`,
 
EOF
)