 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/App.js b/mobile/App.js
index 81be0e080bb228b4fdd91134212f8bab023b9472..6a7068ef5f73c30439ac20c88031c8e926aab769 100644
--- a/mobile/App.js
+++ b/mobile/App.js
@@ -1,50 +1,50 @@
 import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
 import { useFocusEffect } from "@react-navigation/native";
 import {
   Text,
   View,
   StyleSheet,
   TextInput,
   Button,
   Alert,
   ActivityIndicator,
   ScrollView,
   TouchableOpacity,
   Switch,
   Linking,
   Platform,
   Image,
   KeyboardAvoidingView,
   TouchableWithoutFeedback,
   Keyboard,
   Pressable,
   RefreshControl,
   Share,
   AppState,
 } from "react-native";
-import { NavigationContainer } from "@react-navigation/native";
+import { NavigationContainer, StackActions } from "@react-navigation/native";
 import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
 import { enableScreens } from "react-native-screens";
 import axios from "axios";
 import AsyncStorage from "@react-native-async-storage/async-storage";
 import { clearToken, loadToken, saveToken } from "./src/components/tokenStorage";
 import ProviderCard from "./src/components/ProviderCard";
 import { createApiClient } from "./src/api/client";
 import * as Location from "expo-location";
 import Constants from "expo-constants";
 import * as ImagePicker from "expo-image-picker";
 import { Ionicons } from "@expo/vector-icons";
 import { SafeAreaProvider,SafeAreaView } from "react-native-safe-area-context";
 import BookitGYLogoTransparent from "./assets/bookitgy-logo-transparent.png"
 import { theme } from "./src/theme";
 // import * as Sentry from "sentry-expo";
 
 let Clipboard = null;
 try {
   Clipboard = require("expo-clipboard");
 } catch (e) {}
 
 enableScreens(false);
 
 
 
@@ -72,50 +72,56 @@ const withTimeout = (promise, ms, label) => {
       error.code = "ETIMEDOUT";
       reject(error);
     }, ms);
   });
 
   return Promise.race([promise, timeout]).finally(() => {
     clearTimeout(timeoutId);
   });
 };
 
 const AUTH_BOOTSTRAP_WATCHDOG_MS = 15000;
 const AUTH_TOKEN_TIMEOUT_MS = 2000;
 const AUTH_ME_TIMEOUT_MS = 12000;
   const isValidEmail = (value) => {
   const trimmed = value.trim();
   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
   return emailRegex.test(trimmed);
 };
 
 const isValidUsername = (value) => {
   const trimmed = String(value || "").trim();
   if (!trimmed) return false;
   return /^[a-zA-Z0-9._-]+$/.test(trimmed);
 };
 
+const normalizeSearchValue = (value) =>
+  String(value || "")
+    .replace(/[\u200B-\u200D\uFEFF]/g, "")
+    .trim()
+    .toLowerCase();
+
 const resolveImageUrl = (url) => {
     if (!url || typeof url !== "string") return null;
     if (url.startsWith("http")) return url;
     if (url.startsWith("//")) return `https:${url}`;
     const normalizedPath = url.startsWith("/") ? url : `/${url}`;
     return `${API}${normalizedPath}`;
   };
 
 const LEGACY_ACCESS_TOKEN_KEY = "accessToken";
 
 const getAuthToken = async (tokenState) => {
   if (tokenState?.token) return tokenState.token;
 
   try {
     const secure = await withTimeout(loadToken(), 1500, "loadToken");
     if (secure) return secure;
   } catch (error) {
     console.log("[auth] Failed to load secure token", error?.message || error);
   }
 
   try {
     const legacy = await withTimeout(
       AsyncStorage.getItem(LEGACY_ACCESS_TOKEN_KEY),
       1500,
       "loadLegacyToken"
@@ -183,61 +189,67 @@ function extractUsernameFromUrl(url) {
 
   if (!username) return null;
 
   let decoded = username;
   try {
     decoded = decodeURIComponent(username);
   } catch (error) {
     decoded = username;
   }
 
   const cleaned = decoded.trim().replace(/^@/, "");
   if (!cleaned || !isValidUsername(cleaned)) return null;
   return cleaned;
 }
 
 function buildProviderPublicLink(username) {
   const trimmed = String(username || "").trim();
   if (!trimmed) return null;
   return `https://bookitgy.com/u/${encodeURIComponent(trimmed)}`;
 }
 
 function navigateToClientSearch(username, navigationRef) {
   if (!navigationRef?.current) return false;
 
   const params = { incomingUsername: username, deeplinkNonce: Date.now() };
+  console.log("[deeplink] navigateToClientSearch", username, params.deeplinkNonce);
+  const navigation = navigationRef.current;
+  const rootState = navigation.getRootState?.();
+  const tabRouteNames = ["Home", "Search", "Appointments", "Profile"];
+  const rootRouteNames = rootState?.routes?.map((route) => route.name) || [];
+  const hasClientTabs = tabRouteNames.every((name) =>
+    rootRouteNames.includes(name)
+  );
 
-  navigationRef.current.reset({
-    index: 1,
-    routes: [
-      { name: "Home" },
-      { name: "Search", params },
-      { name: "Appointments" },
-      { name: "Profile" },
-    ],
-  });
+  if (hasClientTabs) {
+    navigation.navigate("Search", params);
+    navigation.dispatch(StackActions.popToTop());
+    return true;
+  }
 
+  navigation.navigate("Search", params);
+  navigation.dispatch(StackActions.popToTop());
   return true;
 }
 
 
 function useFavoriteProviders(userKey) {
   const storageKey = FAVORITES_STORAGE_KEY(userKey);
   const [favoriteIds, setFavoriteIds] = useState([]);
   const [favoriteProviders, setFavoriteProviders] = useState([]);
   const [favoritesLoading, setFavoritesLoading] = useState(true);
 
   const persistIds = useCallback(async (ids) => {
     try {
       await AsyncStorage.setItem(storageKey, JSON.stringify(ids));
     } catch (err) {
       console.log("Error saving favorites", err?.message || err);
     }
   }, [storageKey]);
 
   const loadFavoritesFromStorage = useCallback(async () => {
     try {
       setFavoritesLoading(true);
       const raw = await AsyncStorage.getItem(storageKey);
       const parsed = raw ? JSON.parse(raw) : [];
       setFavoriteIds(Array.isArray(parsed) ? parsed : []);
     } catch (err) {
@@ -2813,88 +2825,95 @@ function SearchScreen({ token, showFlash, navigation, route, toggleFavorite, isF
   }, [showFlash, syncFavoritesFromList]);
 
   // Load providers on mount
   useEffect(() => {
     loadProviders();
   }, [loadProviders]);
 
   useEffect(() => {
     const providerFromNav = route?.params?.provider;
     if (!providerFromNav) return;
 
     const incomingId = getProviderId(providerFromNav);
     const currentId = getProviderId(selectedProvider);
     if (incomingId && incomingId === currentId) return;
 
     setSearchQuery(providerFromNav.name || "");
     setHasSearched(true);
     setFilteredProviders([providerFromNav]);
     handleSelectProvider(providerFromNav);
   }, [route?.params?.provider, selectedProvider, handleSelectProvider]);
 
   // Add a useEffect that recomputes filteredProviders
   // whenever providers/search/radius/location changes:
   useEffect(() => {
     // ðŸ‘‡ do nothing until the user actually searches or if the query is empty
-    const trimmedQuery = searchQuery.trim();
-    if (!hasSearched || !trimmedQuery) {
+    const normalizedQuery = normalizeSearchValue(searchQuery);
+    if (!hasSearched || !normalizedQuery) {
       setFilteredProviders([]);
       return;
     }
 
     const providerList = Array.isArray(providers) ? providers : [];
-    const deeplinkUsername = (incomingUsername || "").trim().toLowerCase();
+    const deeplinkUsername = normalizeSearchValue(incomingUsername);
     if (
       deeplinkUsername &&
-      trimmedQuery.toLowerCase() === deeplinkUsername
+      normalizedQuery === deeplinkUsername
     ) {
+      console.log(
+        "[search] deeplink exact attempt",
+        deeplinkUsername
+      );
       const exact = providerList.filter((p) => {
-        const u1 = (p.username || "").trim().toLowerCase();
-        const u2 = (p.user?.username || "").trim().toLowerCase();
+        const u1 = normalizeSearchValue(p.username);
+        const u2 = normalizeSearchValue(p.user?.username);
         return u1 === deeplinkUsername || u2 === deeplinkUsername;
       });
       console.log(
         "[search] deeplink exact username",
         deeplinkUsername,
         "matches",
         exact.length
       );
-      setFilteredProviders(exact);
-      return;
+      if (exact.length > 0) {
+        setFilteredProviders(exact);
+        return;
+      }
+      console.log("[search] deeplink exact miss, falling back to fuzzy");
     }
 
-    const q = trimmedQuery.toLowerCase();
+    const q = normalizedQuery;
     const providerFromNav = route?.params?.provider;
     const navProviderId = getProviderId(providerFromNav);
-    const navProviderName = (providerFromNav?.name || "").trim().toLowerCase();
+    const navProviderName = normalizeSearchValue(providerFromNav?.name);
 
     // If we navigated in with a specific provider, keep the results scoped
     // to that provider ID so namesakes don't appear.
     if (
       navProviderId &&
       navProviderName &&
-      trimmedQuery.toLowerCase() === navProviderName
+      normalizedQuery === navProviderName
     ) {
       const exactMatch = providerList.find(
         (p) => getProviderId(p) === navProviderId
       );
 
       setFilteredProviders([exactMatch || providerFromNav]);
       return;
     }
 
     let list = providerList.map((p) => {
       let distance_km = null;
       if (clientLocation && p.lat != null && p.long != null) {
         distance_km = haversineKm(
           clientLocation.lat,
           clientLocation.long,
           p.lat,
           p.long
         );
       }
       return { ...p, distance_km };
     });
 
     // text filter (profession/name/location)
     if (q) {
       list = list.filter((p) => {
@@ -6220,56 +6239,58 @@ function App() {
 
     Linking.getInitialURL().then((url) => {
       if (!isActive) return;
       console.log("[deeplink] getInitialURL", url);
       if (DEEPLINK_DEBUG) {
         showFlash("info", `[DL] getInitialURL: ${url || "(null)"}`);
       }
       if (url && url !== lastHandledUrlRef.current) {
         handleIncomingUrl(url, "initial");
       }
     });
 
     const sub = Linking.addEventListener("url", ({ url }) => {
       handleIncomingUrl(url, "event");
     });
 
     return () => {
       isActive = false;
       sub.remove();
     };
   }, [handleIncomingUrl]);
 
   useEffect(() => {
     const sub = AppState.addEventListener("change", (nextState) => {
       if (nextState !== "active") return;
+      console.log("[deeplink] AppState active handler");
       Linking.getInitialURL().then((url) => {
         console.log("[deeplink] getInitialURL (active)", url);
         if (DEEPLINK_DEBUG) {
           showFlash("info", `[DL] getInitialURL(active): ${url || "(null)"}`);
         }
-        if (!url || url === lastHandledUrlRef.current) return;
+        const username = extractUsernameFromUrl(url);
+        if (!username) return;
         handleIncomingUrl(url, "appstate-active");
       });
     });
 
     return () => {
       sub.remove();
     };
   }, [handleIncomingUrl]);
 
   useEffect(() => {
     if (!pendingDeepLinkUsername) return;
     if (!token) return;
     if (token.isProvider) {
       showFlash("error", "Open as a client to view provider links.");
       setPendingDeepLinkUsername(null);
       return;
     }
     if (!navReady) return;
     if (!navigationRef.current) return;
 
     const ok = navigateToClientSearch(
       pendingDeepLinkUsername.username,
       navigationRef
     );
     console.log(
 
EOF
)