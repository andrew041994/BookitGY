 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/app/crud.py b/backend/app/crud.py
index 44aeaab39af6dcfbb5f96295ca1ef9857f147a3c..8da68bf12bc473cf4e23ce9c5e9a523b8171999e 100644
--- a/backend/app/crud.py
+++ b/backend/app/crud.py
@@ -705,81 +705,90 @@ def authenticate_user(db: Session, email: str, password: str):
 
 def _hash_deleted_value(value: Optional[str]) -> Optional[str]:
     if not value:
         return None
     normalized = value.strip().lower()
     if not normalized:
         return None
     return hashlib.sha256(normalized.encode("utf-8")).hexdigest()
 
 
 def delete_user_account(
     db: Session,
     user: models.User,
     password: str,
 ) -> None:
     if not verify_password(password, user.hashed_password):
         raise ValueError("Incorrect password")
 
     deletion_id = os.urandom(16).hex()
     placeholder_email = f"deleted_{deletion_id}@deleted.bookitgy"
     placeholder_username = f"deleted_user_{deletion_id[:8]}"
 
     deleted_email_hash = _hash_deleted_value(user.email)
     deleted_phone_hash = _hash_deleted_value(user.phone)
 
+    provider = None
     transaction = db.begin_nested() if db.in_transaction() else db.begin()
-    with transaction:
-        user.is_deleted = True
-        user.deleted_at = now_guyana()
-        user.token_version = (user.token_version or 0) + 1
-        user.deleted_email_hash = deleted_email_hash
-        user.deleted_phone_hash = deleted_phone_hash
-        user.email = placeholder_email
-        user.username = placeholder_username
-        user.phone = None
-        user.whatsapp = None
-        user.expo_push_token = None
-        user.location = None
-        user.lat = None
-        user.long = None
-        user.avatar_url = None
-        user.is_email_verified = False
-        user.email_verified_at = None
-        user.password_reset_at = None
-
-        provider = get_provider_by_user_id(db, user.id)
+    try:
+        with transaction:
+            user.is_deleted = True
+            user.deleted_at = now_guyana()
+            user.token_version = (user.token_version or 0) + 1
+            user.deleted_email_hash = deleted_email_hash
+            user.deleted_phone_hash = deleted_phone_hash
+            user.email = placeholder_email
+            user.username = placeholder_username
+            user.phone = None
+            user.whatsapp = None
+            user.expo_push_token = None
+            user.location = None
+            user.lat = None
+            user.long = None
+            user.avatar_url = None
+            user.is_email_verified = False
+            user.email_verified_at = None
+            user.password_reset_at = None
+
+            provider = get_provider_by_user_id(db, user.id)
+            if provider:
+                provider.is_locked = True
+                provider.bio = None
+                provider.avatar_url = None
+                db.query(models.Service).filter(
+                    models.Service.provider_id == provider.id
+                ).update(
+                    {models.Service.is_active: False},
+                    synchronize_session=False,
+                )
+        db.commit()
+        db.refresh(user)
         if provider:
-            provider.is_locked = True
-            provider.bio = None
-            provider.avatar_url = None
-            db.query(models.Service).filter(
-                models.Service.provider_id == provider.id
-            ).update(
-                {models.Service.is_active: False},
-                synchronize_session=False,
-            )
+            db.refresh(provider)
+    except Exception:
+        db.rollback()
+        raise
 
 
 def verify_user_email(db: Session, user: models.User) -> models.User:
     """Mark a user's email as verified."""
     user.is_email_verified = True
     user.email_verified_at = now_guyana()
     db.commit()
     db.refresh(user)
     return user
 
 def update_user(
     db: Session,
     user_id: int,
     user_update: schemas.UserUpdate,
 ) -> Optional[models.User]:
     """
     Partially update a user using fields from UserUpdate.
     Only fields that are actually provided (exclude_unset=True) are changed.
     """
     user = db.query(models.User).filter(models.User.id == user_id).first()
     if not user:
         return None
 
     # Only apply fields that were sent in the request
     update_data = user_update.dict(exclude_unset=True)
 
EOF
)