 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/mobile/plugins/strip-pods-privacyinfo.js b/mobile/plugins/strip-pods-privacyinfo.js
index ad9a6d7bfa464d9948efcfdfb78059cecb6faf1d..0b93635207ac2d677df4e347247da0292215ba70 100644
--- a/mobile/plugins/strip-pods-privacyinfo.js
+++ b/mobile/plugins/strip-pods-privacyinfo.js
@@ -1,37 +1,41 @@
 const fs = require("fs");
 const path = require("path");
 const { withDangerousMod } = require("@expo/config-plugins");
 
 const PODFILE_MARKER = "# BOOKITGY_PRIVACYINFO_STRIP";
 
+function escapeRegExp(string) {
+  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+}
+
 function findPbxprojFiles(iosDir) {
   const pbxprojFiles = new Set();
 
   const entries = fs.readdirSync(iosDir, { withFileTypes: true });
   for (const entry of entries) {
-    if (entry.isDirectory() && entry.name.endsWith(".xcodeproj")) {
+    if (entry.isDirectory() && entry.name.endsWith(".xcodeproj") && entry.name !== "Pods.xcodeproj") {
       const candidate = path.join(iosDir, entry.name, "project.pbxproj");
       if (fs.existsSync(candidate) && !candidate.includes(`${path.sep}Pods${path.sep}`)) {
         pbxprojFiles.add(candidate);
       }
     }
   }
 
   return Array.from(pbxprojFiles);
 }
 
 function isPodsPrivacyPath(rawPath) {
   if (!rawPath) return false;
 
   const normalized = rawPath.trim().replace(/^"|"$/g, "");
   const lower = normalized.toLowerCase();
 
   return (
     lower.includes("/pods/") ||
     lower.startsWith("pods/") ||
     lower.includes("target support files")
   );
 }
 
 function collectPrivacyFileRefs(content) {
   const fileRefs = new Set();
@@ -120,138 +124,148 @@ function processPbxproj(pbxprojPath) {
   );
   updated = buildFilesStrip.content;
 
   const fileRefsStrip = stripEntries(updated, fileRefsToRemove, "PrivacyInfo.xcprivacy");
   updated = fileRefsStrip.content;
 
   const resourcesStrip = stripResourcesReferences(updated, buildFilesToRemove);
   updated = resourcesStrip.content;
 
   if (updated !== original) {
     fs.writeFileSync(pbxprojPath, updated);
   }
 
   const totalRemoved = buildFilesStrip.removed + fileRefsStrip.removed + resourcesStrip.removed;
   console.log(
     `[strip-pods-privacyinfo] Removed ${totalRemoved} PrivacyInfo.xcprivacy references from ${path.relative(
       process.cwd(),
       pbxprojPath
     )}`
   );
 }
 
 function buildPodfileSnippet(indent) {
   const lines = [
     `${indent}${PODFILE_MARKER}`,
-    `${indent}scripts = Dir.glob(File.join(__dir__, "Pods", "Target Support Files", "**", "*-resources.sh"))`,
     `${indent}removed = 0`,
-    `${indent}scripts.each do |script|`,
-    `${indent}  next unless File.exist?(script)`,
-    `${indent}  content = File.read(script)`,
-    `${indent}  next unless content.include?("PrivacyInfo.xcprivacy")`,
     "",
-    `${indent}  filtered = content.lines.reject { |line| line.include?("PrivacyInfo.xcprivacy") }.join`,
-    `${indent}  removed += (content.lines.length - filtered.lines.length)`,
-    `${indent}  File.write(script, filtered)`,
+    `${indent}# 1) Strip from resources shell scripts`,
+    `${indent}scripts = Dir.glob(File.join(__dir__, "Pods", "Target Support Files", "**", "*-resources.sh"))`,
+    `${indent}scripts.each do |p|`,
+    `${indent}  next unless File.exist?(p)`,
+    `${indent}  c = File.read(p)`,
+    `${indent}  next unless c.include?("PrivacyInfo.xcprivacy")`,
+    `${indent}  n = c.lines.reject { |line| line.include?("PrivacyInfo.xcprivacy") }.join`,
+    `${indent}  if n != c`,
+    `${indent}    removed += (c.lines.length - n.lines.length)`,
+    `${indent}    File.write(p, n)`,
+    `${indent}  end`,
     `${indent}end`,
-    `${indent}puts "[BookitGY] Stripped #{removed} PrivacyInfo.xcprivacy lines from Pods resources scripts"`,
+    "",
+    `${indent}# 2) Strip from xcfilelists (these drive Xcode output tracking)`,
+    `${indent}filelists = Dir.glob(File.join(__dir__, "Pods", "Target Support Files", "**", "*resources-*-files.xcfilelist"))`,
+    `${indent}filelists.each do |p|`,
+    `${indent}  next unless File.exist?(p)`,
+    `${indent}  c = File.read(p)`,
+    `${indent}  next unless c.include?("PrivacyInfo.xcprivacy")`,
+    `${indent}  n = c.lines.reject { |line| line.include?("PrivacyInfo.xcprivacy") }.join`,
+    `${indent}  if n != c`,
+    `${indent}    removed += (c.lines.length - n.lines.length)`,
+    `${indent}    File.write(p, n)`,
+    `${indent}  end`,
+    `${indent}end`,
+    "",
+    `${indent}puts "[BookitGY] Stripped #{removed} PrivacyInfo.xcprivacy references from CocoaPods resources scripts/filelists"`,
     "",
   ];
 
   return lines.join("\n");
 }
 
 function findHookEnd(content, startIndex) {
   const remainder = content.slice(startIndex);
   const lines = remainder.split("\n");
   let depth = 0;
   let position = startIndex;
 
   for (const line of lines) {
     const lineStart = position;
     const doCount = (line.match(/\bdo\b/g) || []).length;
     const endCount = (line.match(/\bend\b/g) || []).length;
 
     depth += doCount;
     depth -= endCount;
 
     if (depth === 0) {
       return lineStart;
     }
 
     position += line.length + 1;
   }
 
   return null;
 }
 
 function findHook(content, hookName) {
   const hookMatch = content.match(
     new RegExp(`^[ \t]*${hookName}\\s+do\\s*\\|[^|]*\\|.*$`, "m")
   );
 
   if (!hookMatch) {
     return null;
   }
 
   const hookStart = hookMatch.index;
   const hookEnd = findHookEnd(content, hookStart);
 
   if (hookEnd === null) {
     return null;
   }
 
   return { start: hookStart, end: hookEnd, indent: hookMatch[0].match(/^[ \t]*/)[0] };
 }
 
 function removeSnippetFromHook(content, hook) {
-  const { end, indent } = hook;
+  const { start, end, indent } = hook;
   const snippet = buildPodfileSnippet(`${indent}  `);
-  const before = content.slice(0, end);
-  const after = content.slice(end);
+  const hookContent = content.slice(start, end);
 
-  if (!before.includes(PODFILE_MARKER)) {
+  if (!hookContent.includes(PODFILE_MARKER)) {
     return content;
   }
 
-  let cleanedBefore = before;
-  const snippetIndex = before.indexOf(snippet);
-
-  if (snippetIndex !== -1) {
-    cleanedBefore = before.slice(0, snippetIndex) + before.slice(snippetIndex + snippet.length);
-  } else {
-    const lines = before.split("\n");
-    const markerIndex = lines.findIndex((line) => line.includes(PODFILE_MARKER));
-    if (markerIndex !== -1) {
-      cleanedBefore = lines.slice(0, markerIndex).join("\n");
-      if (!cleanedBefore.endsWith("\n")) {
-        cleanedBefore += "\n";
-      }
-    }
+  let cleanedHook = hookContent.replace(snippet, "");
+
+  if (cleanedHook === hookContent) {
+    const markerBlockRegex = new RegExp(
+      `\n?[\\t ]*${escapeRegExp(PODFILE_MARKER)}[\\s\\S]*?(?=\n${indent}end)`,
+      "m"
+    );
+    cleanedHook = hookContent.replace(markerBlockRegex, "\n");
   }
 
-  return cleanedBefore + after;
+  return content.slice(0, start) + cleanedHook + content.slice(end);
 }
 
 function injectSnippetIntoHook(content, hook) {
   const { end, indent } = hook;
   const snippet = buildPodfileSnippet(`${indent}  `);
 
   const before = content.slice(0, end);
   const after = content.slice(end);
 
   const needsLeadingNewline = before.endsWith("\n") ? "" : "\n";
 
   return `${before}${needsLeadingNewline}${snippet}${after}`;
 }
 
 function injectPodfilePrivacyStrip(iosDir) {
   const podfilePath = path.join(iosDir, "Podfile");
   if (!fs.existsSync(podfilePath)) {
     return;
   }
 
   let podfileContent = fs.readFileSync(podfilePath, "utf8");
 
   const postInstall = findHook(podfileContent, "post_install");
   if (postInstall) {
     podfileContent = removeSnippetFromHook(podfileContent, postInstall);
 
EOF
)